
Logic (code <-> visual)
=======================

code -> visual
--------------
- "compile" code, generate object instance(s)
- finest grain (best level of control, more complex)

visual -> code
--------------
- based on user input (drag/translate objects, rotate them, scale them etc):
  * object INSTANCE attribute changes 
  * generate / MODIFY corresponding code
    * generation easier than rewrite
  * transformation stack/history can be "collapsed": ie when doing these operations manually
    
    translate([2,0,O])
    translate([0,3,0])
    
    same as (this is what you would write in code)
    
    translate([2,3,0])
  
  * operation order is important: translation , rotation scale order matters -> relatively trivial
  * how do we handle loops etc ? 


syntaxic analysis and alteration
================================

We need to know for a given "visual" ITEM (part, shape)
- where is the ITEM  defined
- where is the ITEM used
if the ITEM is used nowhere: do not recompile? 

if an item was added( to any object or main assembly), remove old instance, add new one
alternatively : generate a "wrapper" around created objects, only replace the innards ??

if an item has NO instance : do not recompile ??? 
  see : http://ariya.ofilabs.com/2012/11/polluting-and-unused-javascript-variables.html

very interesting read ( closely related):
https://code.google.com/p/esprima/issues/detail?can=2&q=90&colspec=ID%20Type%20Status%20Priority%20Milestone%20Owner%20Summary&id=90

ALTERNATIVE SOLUTIONS:
---------------------
the problem is actually a SCOPE problem: 
if you are editing a PART (within it) you are in the SCOPE of that part : ie we can disregard
the rest of the code until editing it done

we can draw a parallel to visual editing: 
  - double clicking on a part/shape would go into an edit mode where all other elements are grayed out,
  and we are in the local coordinate system of the element being edited

classes and instances:
---------------------
it is important to make a distinction between classes (or functions etc) and their instances

Instance differentiation:
 - instances can be differentiated based on a hash generated from their input parameters (
similarly to how the bom system handles it in the current implementation)
  - depending on instance size (very variable based on geometric back end) 

code analysis tools:
====================
-esprima !:
 http://esprima.org/index.html

- escope (scope analysis)
  https://github.com/Constellation/escope

- esrefactor (alter code)
  https://github.com/ariya/esrefactor

- falafel (alter code) https://github.com/substack/node-falafel

- esgraph visualization https://github.com/Swatinem/esgraph

2 main problems to resolve (seperate but tangentially related)
-------------------------
- bidirectional shape edition
- code compilation optimisation (do not recompile everything when
 only an independant subset has changes)


additional issues
=================
- coffeescript : are sourcemaps sufficient to get a precise level of control ?
  * to map cursor coordinates (0 based index) from the editor(coffeescript) to coordinates (col, line) actually
useable by the various esprima tools we need: 
      * source map generated by coffeescript : returns json string
      * inject file/source name into the source map json object above
      * on a click in the editor : 
        - take zero based index (coffee) convert to line, column
        - use sourcemapConsumer.generatedPositionFor(coffeeCursorLocationData); to get back the location in the generated source

- intermediary coffee-> js step : could be circumvented with coffeescript-redux, but that 
still lacks support for super() (!!!!!)

- for now only this tracking works:

    var myCube = new Cube();

but this does not

    myCube = new Cube(); 

assignments should be checked, not just instanciations

Prototyping (various)
=====================
Step1 (js)
- when selecting an object in 3D view, show its location in the code view -> done, for javascript
- when selecting an object instance or class in code view, highlight it in 3D view -> done, for javascript


Step2 (coffee)
- all of the above should work with coffeescript too: 
- work on remaping coffee <-> js coordinates -> will not work
- define a set of helpers in ast-manipulator for detecting class instances (for now should be seperate from pure js node type detection) ->done


Update:February 01 2014:
========================
Good news/bad news:
- a much cleaner implementation to trace classes, instances of those classes, and basic bi-directional SELECTION of objects
(code <-> visual) works !
- but sadly , for javascript only: 
while tracing classes and their instances works (and is implemented) for the transpiled javascript from coffeescripts, 
the (what I thought would be the most trivial) task of mapping a code index/ coordinate (line,column), from the original coffeescript
file to the generated js files sadly does NOT:
  * it turns out source maps generated by coffee-script (standard, not redux) are totally unreliable : in even basic files
(two "empty" classes, and one instance of each) the maps points to a lot of positions in the js file, making this UNUSABLE!
  unless I am missing something, there is no way out....
  * alternate solution using coffeescript redux (which has higher quality source maps, and its own syntax tree which could be used), is not usuable at this point, because of the lack of "super" keyword support...see: https://github.com/michaelficarra/CoffeeScriptRedux/issues/244

This means either:
 * ditching coffeescript ....
 * manual parsing of start/stop locations, scope etc ...
 * finding some other mapping solution
 * calling in the flying monkey squad

In the meantime, prototyping the algorithms and the logic / base implementation in javascript seems the only way to go forward for now

Algorithm so far:
classes:
- find all class definitions, get their ranges (start-end)
- inject that range into their __meta attributes to keep track of their range
- find all instanciations of the classes we found:
    * and push each one into the partInstancesByType "module" variable (maps class names to a list of instances)
    this is basically "auto registration of an instance based on class name"
      * this allows the code -> visual tracking of the CLASS of a given instance
    * add the classe's range data into the instances __meta attribute 
      * this allows the visual -> code tracking of the CLASS of a given instance

Instances:
- find all variable instanciations and asignments which create one of the classes found previously
- inject the range of that variable instanciation/asignement into the instance's __meta.instancesData attribute
  * this will allow visual -> code tracking for a given instance of a mesh
- inject a (range to instance mapping) into the codeLocToinstances "module" variable (stores this data for all these special
variables within our custom module class) 
  * this will enable code --> visual tracking for a specific instance of a mesh


