
<link rel="import" href="../../components/usco-client-deps/usco-client-deps.html">
<link rel="import" href="../../components/usco-asset-manager/usco-asset-manager.html">

<link rel="import" href="../../components/usco-xhr-store/xhr-store.html">
<link rel="import" href="../../components/usco-desktop-store/desktop-store.html">
<link rel="import" href="../../components/usco-dropbox-store/dropbox-store.html">
<link rel="import" href="../../components/usco-fs-store/fs-store.html">

<link rel="import" href="../../components/usco-amf-parser/amf-parser.html">
<link rel="import" href="../../components/usco-stl-parser/stl-parser.html">
<link rel="import" href="../../components/usco-obj-parser/obj-parser.html">
<link rel="import" href="../../components/usco-ply-parser/ply-parser.html">
<link rel="import" href="../../components/usco-ctm-parser/ctm-parser.html">


<polymer-element name="assembly-viewer" attributes="showAxis showIndicators">
    <template>
      <assembly-step id="assemblyStep" showIndicators="{{showIndicators}}" ></assembly-step>
      
      <!--ui elements-->
      <template if="{{currentStep < totalSteps}}">
        <div style="position:absolute;right:10px;top:300px;z-index:5"> <button on-tap="{{nextStep}}">Next step</button> </div>
      </template>
      <template if="{{currentStep >1 }}">
      <div style="position:absolute;right:100px;top:300px;z-index:5"> <button on-tap="{{prevStep}}">Prev step</button> </div>
      </template>
      <!--core elements: loaders, viewer etc-->
      <usco-client-deps> </usco-client-deps>
      <usco-asset-manager id="assetManager">
        <xhr-store> </xhr-store>
        <desktop-store> </desktop-store>
        <dropbox-store> </dropbox-store>
        <fs-store> </fs-store>

        <amf-parser> </amf-parser>
        <stl-parser> </stl-parser>
        <obj-parser> </obj-parser>
        <ply-parser> </ply-parser>
        <ctm-parser> </ctm-parser>
      </usco-asset-manager>
      
      <three-js id="threeJs" selectedObjects="{{selectedMeshes}}" highlightedObject="{{highlightedMesh}}">
        <three-stats id="stats" show=false></three-stats>
        <tween-js> </tween-js>
        <three-js-webglRenderer id="webglRenderer"></three-js-webglRenderer>
        <!--<three-js-css3dRenderer id="css3dRenderer"></three-js-css3dRenderer>-->
        <three-js-combinedCamera id="cam1" pos="[100,50,200]" orientation="diagonal" up=[0,0,1]></three-js-combinedCamera>

        <three-js-scene name="main" active pickable>
          <three-js-light pos="[250,230,200]"></three-js-light>
          <three-js-light kind="spot" pos=[150,350,290] shadow></three-js-light>
          <three-js-light pos="[-250,-230,-200]"></three-js-light>
          
          <!--<three-js-light kind="dir" color="0xffEEEE" intensity="0.2" pos=[0,50,300] > </three-js-light> 
          <three-js-light kind="ambient" color="0x161515" intensity="0.8"> </three-js-light>
          <three-js-light kind="hemi" color="0xffffff" secColor="0xffffff" intensity="0.5" pos=[0,1200,5000]> </three-js-light>-->
          
        </three-js-scene>
        
        <three-js-scene name="helpers" active>
          <template if="{{showAxis}}">
            <three-axis-helper> </three-axis-helper>
          </template>
        </three-js-scene>
      
        <three-js-viewport name="perspective" id="perspectiveView" cameraId="#cam1" left=0 bottom=0 width=0.5 height=1.0 postProcess>
          <three-js-orbitControls cameraUp=[0,0,1] autoRotateSpeed="10"> </three-js-orbitControls>
          <!--<three-effect-composer ignore=["helpers"]>
            <vignette-fx> </vignette-fx>
          </three-effect-composer>-->
        </three-js-viewport>
      </three-js>
    </template>
    <script>Polymer("assembly-viewer", {
      //visual settings
      showAxis:false,
      showIndicators:true,
      
      instructions:null,
      currentStep:0,
      totalSteps:0,
      level:null,
      
      assembly: null,
      
      dataPerSteps: null,
      bomPerStep:null,
      
      highlightedMesh:null,
      selectedMeshes:null,
      
      //TODO: should these be here ?
      
      enteredView:function()
      {
        this.threeJs      = this.$.threeJs;
        this.assetManager = this.$.assetManager;
        this.assemblyStep = this.$.assemblyStep;
        
        //this.meshHighlightEffect = new 
        
        this.dataPerSteps = {};
        //FIXME:this is a big ole' hack: for now get different things based on uri of 3d file
        this.bomPerStep = {};
      },
      //attribute change callbacks
      instructionsChanged:function()
      {
        console.log("instructions changed");
      },
      assemblyChanged:function(){
        console.log("assembly changed");
        var nodes = [];
        this.recurse(this.assembly[0], nodes);
        
        console.log("assemblable nodes", nodes);
        this._hierarchyNodes = nodes ;

        //this gives us the actual logical build steps: depth first, because children
        //need to be completed/assembled before their parents
        
        //set various attributes and flags related to current step
        var currentStepData = nodes[0];
        this.currentStepData = currentStepData;
        this.currentStep = 1;
        this.totalSteps = nodes.length;
      },
      currentStepChanged:function(oldStep,newStep)
      {
        var nodes = this._hierarchyNodes;
        var currentStepData = nodes[this.currentStep-1];
        this.currentStepData = currentStepData;          
        //load data for current step
        //TODO: add this to resource manager
        var basePath = window.location.href.split("/")
        basePath.pop()
        basePath = basePath.join("/");
        
        //load main item 3d data + all its children
        //FIXME: a resulting shape should not even have 3d data of its own
        
        var resultShape = new THREE.Object3D();

        var uri = currentStepData.uri;
        var currentUrl = basePath;
        var self = this;
        //TODO : detect lack of url prefix
        this.loadResource( currentUrl+"/"+uri, function(loadedShape){ 
          loadedShape.name = uri;
          resultShape.add(loadedShape);
          self.fillBomPerStep(currentStepData, loadedShape);
        } );


        for(var i=0;i<currentStepData.children.length;i++)
        {
          var self = this;
          
          function wrapper(i)
          {
            var childData = currentStepData.children[i];
            var uri = childData.uri;
            var currentUrl = basePath;
            
            //TODO : detect lack of url prefix
            function callback(loadedShape)
            {
              loadedShape.name = uri;
              self.fillBomPerStep(childData, loadedShape);
              resultShape.add( loadedShape );
              loadedShape.position.x = childData.position[0];
              loadedShape.position.y = childData.position[1];
              loadedShape.position.z = childData.position[2];
              
              loadedShape.material.color.setHex(0xff8800);
              
              
              //add current virtual shape & children to data per step
              loadedShape.lookAt(loadedShape.position.clone().add( new THREE.Vector3().fromArray(childData.up)) );
              
            }
            self.loadResource( currentUrl+"/"+uri, callback );
          }
          wrapper(i);
        }
        
     
          
        //add all loaded stuff to scene
        this.addToScene( resultShape );
        this.dataPerSteps[self.currentStep] = resultShape;
        
        
        //remove from scene the container object of the previously displayed step        
        this.removeFromScene( this.dataPerSteps[oldStep] );
        delete this.dataPerSteps[oldStep];    
        
        //load connectors
        var helpersContainer = new THREE.Object3D();
        if(!(currentStepData.connectors)) return;
        for(var i=0;i<currentStepData.connectors.length;i++)
        {
          var connectorData = currentStepData.connectors[i];
          //console.log(i, connectorData, currentStepData.connectors[0] );
          var up = connectorData.up || [0,0,1];
          up = new THREE.Vector3().fromArray( up );
          var connector = new Connector({up:up});
          connector.position.fromArray( connectorData.position );
          
          //this.addToScene( connector.generateRenderables({color:0x000001,baseDia:3}) );
          helpersContainer.add( connector.generateRenderables({color:0x000001,baseDia:3}) );
          //FIXME: should these arrows be the indicators for a verb
          //should they be what the manual's creator defines?
          
          var end   = new THREE.Vector3().fromArray( connectorData.position );
          var start = end.clone().add( up.clone().multiplyScalar(25) );
          var arrow = new DistanceHelper({start: start, end:end});
          //arrow.toggleText(false);
          //hack-ish
          arrow.label.parent.remove(arrow.label);
          //this.label.textSprite.visible = toggle;
          helpersContainer.add( arrow );
        }
        
        resultShape.add( helpersContainer );
        resultShape.indicators = helpersContainer;

        //update current step in controls
        //TODO: use databinding
        this.assemblyStep.current = this.currentStep;
        //this.assemblyStep.bom = this.bomPerStep;
        
      },
      totalStepsChanged:function()
      {
        this.assemblyStep.current = this.currentStep;
        this.assemblyStep.total = this.totalSteps;
      },
      showIndicatorsChanged:function()
      {
        var indicators = this.dataPerSteps[this.currentStep].indicators;
        if(!(indicators)) return;
        
        var visible = this.showIndicators;
        indicators.traverse(function(threeNode){
          threeNode.visible = visible
        });
      },
      highlightedMeshChanged:function(oldHighlight, newHighLight){
        console.log(oldHighlight, newHighLight);
        if(oldHighlight)
        {
          if(oldHighlight._oldColor)
          {
            oldHighlight.material.color = oldHighlight._oldColor;
            //FIXME: is this a hack highlighted
            if(oldHighlight._meta_)
            {
              oldHighlight._meta_.part.highlighted = false;
            }
          }
        }
        if(newHighLight)
        {
          newHighLight._oldColor = newHighLight.material.color;
          newHighLight.material.color = new THREE.Color(0xf03333);
         // newHighLight.material.shininess = 1; 
          if(newHighLight._meta_)
          {
           newHighLight._meta_.part.highlighted = true;
          }
        }
      },
      //helpers
      recurse:function(node, nodes)
      {
        var validNode = true;
        if(node.children)
        {
          for(var i=0;i<node.children.length;i++)
          {
            var child = node.children[i];
            if(!child.children)
            {
              //console.log("blahh", node);
            }
            if(child.children)
            {
              validNode=false;
              this.recurse( child, nodes );
            }
          }
        }
        if(validNode)
          {
            nodes.push( node );
          }
        //nodes.push( node );
      },
      fillBomPerStep:function(partData, instance)
      {
        //console.log("partData", partData);
        var partNumber = partData.partNumber;
        var currentStep = this.currentStep;
        /*Storage per partNumber
        
        if(!(this.bomPerStep[partNumber])) this.bomPerStep[partNumber] = {amount:1,uri:partData.uri,description:"",instances:[]};
        
        this.bomPerStep[partNumber].amount+=1;
        if(this.bomPerStep[partNumber].instances.indexOf(instance) == -1)
        {
          this.bomPerStep[partNumber].instances.push( instance );
        }
        console.log("bomPerStep",this.bomPerStep);*/
        
        //storage as simple list
        if(!(this.bomPerStep[currentStep])) this.bomPerStep[currentStep] = [];
        
        var found = false;
        var parts = this.bomPerStep[currentStep];
        for(var i=0;i<parts.length;i++)
        {
          var part = parts[i];
          if(partNumber == part.partNumber)
          {
            found = true;
            part.amount+=1;
            if(part.instances.indexOf(instance) == -1)
            {
              part.instances.push( instance );
              if(!(instance._meta_))
              {
                instance._meta_= {}
                instance._meta_.part = part;
              }
            }
            break;
          }
        }
        if(!(found))
        {
          //for now, hackiing uri as description
          var part = {partNumber:partNumber, description:partData.uri.replace("demo-data/",""), amount:1,uri:partData.uri,instances:[instance]};
          parts.push( part );
        }
        
        if(!(instance._meta_))
        {
          instance._meta_= {}
          instance._meta_.part = part;
        }
        
        console.log("this.bomPerStep",this.bomPerStep, this);
        this.assemblyStep.bom = this.bomPerStep[currentStep];
      },
      //public API
      addToScene:function(object,sceneName)
      {
        this.threeJs.addToScene(object,sceneName);
      },
      removeFromScene:function(object, sceneName)
      {
        this.threeJs.removeFromScene(object,sceneName);
      },
      loadResource:function(uriOrData, callback)
      {
        var self = this;
        var resourceDeferred = this.assetManager.loadResource(uriOrData);
        resourceDeferred.promise.then(function(resource){
          //geometry
          var geometry = resource.data;
          geometry.computeBoundingBox();
          //geometry.computeCentroids();
          geometry.computeBoundingSphere();

          //needed at least for .ply files
          geometry.computeVertexNormals();
          geometry.computeFaceNormals();

          //nice color: 0x00a9ff
          var material = new THREE.MeshPhongMaterial( { color: 0x17a9f5, shading: THREE.FlatShading} );
          //FIXME: in THREE.js R67> issues with lambert material + lack of compute centroids
          //new THREE.MeshLambertMaterial( {opacity:1,transparent:false,color: 0x0088ff} );
          //
          var shape = new THREE.Mesh(geometry, material);
          if(callback) callback( shape );
          
        }).fail(function(error){console.log("failed to load resource", error);})
      },
      loadInstructions:function(uriOrData)
      {
      
      },
      nextStep:function(){
        if(this.currentStep<this.totalSteps)
        {
          this.currentStep += 1;
        }
      },
      prevStep:function(){
       if(this.currentStep-1 >= 0)
       {
        this.currentStep -= 1;
       }
      }
    });
    </script>
  </polymer-element>
