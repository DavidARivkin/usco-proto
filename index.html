<html>
  <head>
    <meta charset="utf-8">
    <title>Example</title>
      <script src="components/platform/platform.js"></script>
      <link rel="import" href="components/polymer/polymer.html">
      <link rel="import" href="components/ace/ace-element.html">
      <link rel="import" href="components/code-mirror/code-mirror.html">
      <link rel="import" href="components/usco-viewer-base/three-viewer.html">
      <link rel="import" href="components/polymer-ui-tabs/polymer-ui-tabs.html">
     
     
      <script src="components/esprima/esprima.js"></script>
      <script src="components/estraverse/estraverse.js"></script>
      <script src="components/escope/escope.js"></script>
      <script src="components/esrefactor/lib/esrefactor.js"></script>
      <script src="components/esmorph/lib/esmorph.js"></script>

      <script src="vendor/CoffeeScriptRedux.js"></script>
      <script src="vendor/source-map.js"></script>

    <style>
      polymer-ui-tabs > * {
height: 30px;
line-height: 30px;
      }

polymer-ui-tabs > .polymer-selected {
background-color: rgb(85, 153, 255);
color: white;
background-position: initial initial;
background-repeat: initial initial;
border: 1px solid black;
border-radius: 4px 4px 0px 0px;
}

    </style>
  </head>
<body>
  
<script>
//AST experiment input
function test() {
var x = true;

  x = 23;	
  
  x+=1;
var toto = 245;
  
  toto += 23;
  
  if(toto >5)
  {
   console.log("kj"); 
  }
}
        
</script>

  <polymer-element name="foo-editor">
    <template>
      <button on-click="{{compile}}"> Compile </button>
      <button on-click="{{analyze}}"> Analyze </button>
      <button on-click="{{traverseAst}}"> Traverse </button>

      <select value="{{sourceLanguage}}">
        <option value="js"> Js </option>
        <option value="coffee"> Coffee </option>
      </select>
      <div>
        <code-mirror id="editor" theme="monokai" mode="javascript" boundValue="{{source}}" selection="{{selectedText}}"
cursorPos="{{cursorLocation}}" 
on-editor-input="{{editorChanged}}" style="position: absolute;width:25%;top:40px;height:90%">function test() {
var x = true;}
        </code-mirror>

        <code-mirror id="transpiledEditor" theme="monokai" mode="javascript" value="{{compiledSource}}" cursorPos="{{compiledCursorLocation}}"
         style="position: absolute;width:25%;top:40px;left:25%;height:90%"></code-mirror>

        <!--<ace-element theme="solarized_dark" style="width:50%;top:40px" boundValue="{{source}}"  on-editor-input="{{editorChanged}}">
        </ace-element>-->
         <three-viewer id="viewer" selectedObject="{{selectedMesh}}"style="position:absolute;left:50%;height:90%;width:50%" > </three-viewer>
         <!-- <cube-editor style="position: absolute;right:30px;z-index:999999"> </cube-editor> -->
        <div style="position:absolute; left:30%; top:0px"> Selected text: {{selectedText}}, cursor at: {{cursorLocation}} transpiled cursor at: {{compiledCursorLocation}}</div>
        <div style="position:absolute; right:300px; top:0px"> Selected mesh: {{selectedMesh.name}} {{selectedMesh.id}}</div>
        <div style="position:absolute; right:10px; top:0px"> Shapes list
            <ul>
              <li>Cube</li>
              <li>Sphere</li>
              <li>Cylinder</li>
            </ul>
        </div>


      </div>
    </template>
    <script>
    Polymer("foo-editor",{
      source:null,
      selectedText:null,
      cursorLocation : null,
      selectedMesh : null,

      compiledSource:null,
      compiledCursorLocation:null,
      /*project:{files:
        {"toto.js":"some code here"}
      },*/

    created:function()
    {
      //for module system
      this.assembly = new THREE.Object3D();
      this.exports = {};
      this.include = function(){};
      this.importGeom = function(){};
      this.name = "totoModule";

      //for part instance tracing
      this.partInstancesByType = {};

      //language detec
      this.sourceLanguage = "js";
    },
    enteredView:function()
    {
      this.assembly = this.$.viewer.rootAssembly;
      //this.$.viewer.addToScene(this.assembly);

      this.async(function(){ this.$.editor.refresh(); },200);
    },
    _wrapCode:function(code)
    {
       //var pre = "var assembly =  THREE.Object3D();\n"
       var pre = "return (function ( exports, include, importGeom, module, __filename, assembly)";
        pre +="{";
        pre += "var partInstancesByType = module.partInstancesByType;\n";
        pre += code;
        pre += "});";

       var result = pre;
       //console.log("result", result);
       return result
    },

    //Determine if coffeescript or javascript
    _detectLanguage:function()
    {
      var source = this.source;
      var coffeeSymbols = ["class", "->", "=>", "extends"];//not totally true for harmony
      var jsSymbols = ["var", "function"];
      for(var i=0;i<jsSymbols.length;i++)
      {
        var token = jsSymbols[i];
        if( source.indexOf(token) != -1 ){
          this.sourceLanguage = "js";
          return; }
      } 

      for(var i=0;i<coffeeSymbols.length;i++)
      {
        var token = coffeeSymbols[i];
        if( source.indexOf(token) != -1 ){
          this.sourceLanguage = "coffee";
          
          this.$.editor.mode = "coffeescript";
          return;}
      } 
    },
    compile:function()
    {
      if(this.sourceLanguage == "coffee")
      {
        var pseudoModuleName = this.name+".coffee";
        
        console.log("using coffeescript on",this.source,"pseudo module name", pseudoModuleName);
        //coffeescript redux only
        var csAST = CoffeeScript.parse(this.source, {optimise: false, raw: true});
        console.log("coffee ast", csAST);
        var jsAST = CoffeeScript.compile(csAST, {bare: true});
        var compiledSource = this.compiledSource = CoffeeScript.js(jsAST, {compact: false,sourceMap:true,sourceMapFile:pseudoModuleName});
        console.log("compiledSource", compiledSource);
        this.ast = jsAST;

        /*
        var compiledSourceData = CoffeeScript.compile(this.source,{bare:true,sourceMap:true,filename:pseudoModuleName});
        var compiledSource = compiledSourceData.js;
        console.log("compiled coffee", compiledSourceData);
        this.compiledSource = compiledSource;//we keep the generate js
  
        var srcMap = JSON.parse(compiledSourceData.v3SourceMap);
        srcMap.sources = []
        srcMap.sources.push( pseudoModuleName ) 

        this.sourcemapConsumer = new sourceMap.SourceMapConsumer(srcMap);
        console.log("sourcemapConsumer",this.sourcemapConsumer);*/
      }
      else
      { this.analyze(compiledSource); }
      this.traverseAst();
      var alteredSource = this.injectTracing(compiledSource);

      //reset everything before compiling again
      //clear root assembly
      var child, i;
      for ( i = this.assembly.children.length - 1; i >= 0 ; i -- ) {
          child = this.assembly.children[ i ];
          this.assembly.remove(child);
      }
      //reset instances count
      this.partInstancesByType={};
      /////////////////////////////////////

      //wrap modified source with module elements       
      var endSource = this._wrapCode(alteredSource);
      console.log("compiling");
      
      var startTime = new Date();
      try
      {
        var f = new Function(endSource);
        var fn = f();
        var result = fn.call(fn, this.exports, this.include, this.importGeom, this, this.name , this.assembly)
        console.log("result",this.assembly,this.partInstancesByType);
      }
      catch(error)
      {
        console.log("failed to compile:", error.name + ': ' + error.message);
      }
      var endTime = new Date();
      var elapsed = endTime - startTime;
      console.log("code compiling took:"+ elapsed)
    },
    analyze:function(source)
    {
      var startTime = new Date();
      try
      {
        var ast = esprima.parse(source,{loc:true, range:true, tolerant:true});
        var scope = escope.analyze(ast);
        //console.log("ast",ast,"scope", scope);
        this.ast = ast;
      }
      catch(error)
      {
          console.log("failed to generate ast:", error.name + ': ' + error.message);
      }
      var endTime = new Date();
      var elapsed = endTime - startTime;
      console.log("AST generation took:"+ elapsed)
    },
    showRecompiledCode:function()
    {
      //TODO: find a way to display exactly WHAT section of the code was changed
    },
    traverseAst:function()
    {
      console.log("traversing ast")
      var functions = {};
      var classes = {};

      var source = this.source;

      estraverse.traverse(this.ast, {
          enter: function (node, parent) {
              //console.log("node",node)
              if (node.type == 'FunctionExpression' || node.type == 'FunctionDeclaration')
              {
                if(node.id !== null && node.id !== undefined )
                {
                var name = node.id.name;
                functions[name] = {range:node.range};
                //console.log("function",name, "range", node.range, "node",node);
                return estraverse.VisitorOption.skip;
                }
              }
              else if(node.type == 'Identifier' && node.name in functions)
              {
                //console.log("blahh",node.name);
              }
              else if(node.type == 'VariableDeclarator' && node.init && node.init.callee && (node.init.callee.name in classes))
              {
                var instanceName = node.id.name;
                var className = node.init.callee.name;
                console.log("created one instance of", className);
                var nodeSrc = source.slice(node.range[0],node.range[1]);
                console.log("node", node, "source", nodeSrc );
                nodeSrc += ";\n"+instanceName+".meta.foo=42";
                var tempAst = esprima.parse(nodeSrc);
                //node.replace(tempAst);
                //return tempAst;

              }
              else if(node.type=='AssignmentExpression' && node.operator === '='  )
              { 
                console.log("asignment", node.right.arguments, node);

                //"class detection"
                
                if(node.left.object && node.left.object.name && node.right.arguments && node.right.arguments.length >0 && node.right.arguments[0].property && node.right.arguments[0].property.name)
                {
                  var className = node.left.object.name;
                  var bla = node.right.type == "CallExpression" && node.right.arguments[0].property && node.right.arguments[0].property.name =="prototype"

                  if( className in functions && node.left.property.name === "prototype" && bla)
                  {
                    var className = node.left.object.name;
                    //var range = functions[]
                    classes[className]={range:functions[className].range};
                  }
                }
              }
          },
          leave: function (node, parent) {
            if (node.type == 'FunctionExpression' || node.type == 'FunctionDeclaration')
                //console.log("leaving function",node);
                return estraverse.VisitorOption.Skip;
              /*if (node.type == 'VariableDeclarator')
                console.log(node.id.name);*/
          }
      });
      console.log("Functions",functions);
      console.log("classes",classes);
      this._classes = classes;
    },
    injectTracing: function(source)
    {
      //function entry/exit experiments
      functionEntrytracer = esmorph.Tracer.FunctionEntrance(function(fn) {
            var signature;
            console.log("function:",fn,"\n");
            return ""
             /*if (fn.name !== "ctor") {
              return signature = "this.meta = {\n  lineNumber: " + fn.line + ", \n  range: [ " + fn.range[0] + ", " + fn.range[1] + "]\n}";
            } else {
              return "";
            }*/
          });
      functionEndtracer = esmorph.Tracer.FunctionExit(function(fn) {
            if(fn.name == "[Anonymous]" || fn.name == "__extends") return "";//for coffeescript
            //if (fn.name === "Part") return "";
            var additions = "";
            //instance metadata
            //TODO: cleanup : we don't need could, instances list.length should be enough
            additions += "if(! ('"+fn.name +"' in partInstancesByType)) partInstancesByType['"+fn.name+"']={count:0,instances:[]};\n"; 
            additions += "partInstancesByType['"+fn.name+"'].count+=1;\n";
            additions += "partInstancesByType['"+fn.name+"'].instances.push(this);\n";

            //positional metadata
            additions += "   this.meta = {\n  lineNumber: " + fn.line + ", \n  range: [ " + fn.range[0] + ", " + fn.range[1] + "]\n}";
            //TODO: add instance tracing
            additions += "";
            return additions;
          });

      var outSource = esmorph.modify(source, [functionEntrytracer, functionEndtracer])
      //console.log("outputSource",outSource);
      return outSource;
    },

    //change handlers
    sourceLanguageChanged:function()
    {
      this.compile();
    },
    sourceChanged:function()
    {
       this._detectLanguage();
       this.compile();
       //this.analyze();
    },
    selectedMeshChanged:function()
    {
        //console.log("declaration", id.declaration); 
        this.$.editor.clearMarkers();
        var mesh = this.selectedMesh;
        if(!(mesh)) return;
        var pos = this.$.editor.mirror.posFromIndex(mesh.meta.range[0]);
        console.log("current mesh code position",pos)
        this.$.editor.addMarker(pos.line);
    },
    cursorLocationChanged:function()
    {
      //TODO: for coffeescript we need to re-map coordinates of code
      //cursor location (0 based index, in coffeescript) to js

      var context = new esrefactor.Context();
      if(!(this.source)) return;
      context.setCode(this.ast);

      //TODO: refactor: this clears all current visual selections
      var oldSelections = this.currentSelections;
      if(!(this.currentSelections)) this.currentSelections = [];
      if( oldSelections)
      {
        for(var i=0; i< oldSelections.length;i++)
        {
          try{
          var old = oldSelections[i];
          old.remove(old.outline);
          old.outline = null;
          }catch(error){}
        }
      }
      //////////////////////////////////////////////////////
      if(context)
      {
        var cursorLocation = this.cursorLocation
        if( this.sourceLanguage == "coffee" )
        {
          var coffeeCursorLocationData = this.$.editor.mirror.posFromIndex(this.cursorLocation);
          coffeeCursorLocationData.line +=1
          coffeeCursorLocationData.column = coffeeCursorLocationData.ch;
          coffeeCursorLocationData.source = this.name+".coffee";
          delete coffeeCursorLocationData.ch;

          var cursorPosJs = this.sourcemapConsumer.generatedPositionFor(coffeeCursorLocationData);
          cursorPosJs.ch = cursorPosJs.column;
          cursorPosJs.line -=1;

          //TODO: map back to zero based index
          //convert to index ?
          var compiledSource = this.compiledSource;
          console.log("compiledSource length,",compiledSource.length);
          function coordToIndex(coords)
          {
              //console.log("compiled source", compiledSource);
              var lines = compiledSource.split("\n");
              var index = coords.ch;
              //if (coords.line < this.first || coords.ch < 0) return 0;

              for(var i= 0;i<coords.line;i++)
              {
                index+=lines[i].length +1;
              }
              return index;
          }
          /*coords = clipPos(this, coords);
          var index = coords.ch;
          
          this.iter(this.first, coords.line, function (line) {
            index += line.text.length + 1;
          });
          return index;*/
          this.$.transpiledEditor.mirror.doc.setCursor({line:cursorPosJs.line-1, ch:cursorPosJs.ch})          

          var finalPos = coordToIndex(cursorPosJs);
          cursorLocation = finalPos;
          console.log("cursor(coffee)",coffeeCursorLocationData, "js cursor pos", cursorPosJs, "cursorLocation",finalPos);
        }
         
        var id = context.identify(cursorLocation);
        console.log("selection info (from ast)",id)
        this.$.editor.clearMarkers();
        if( !(id && id.declaration)) { return;}

        console.log("declaration", id.declaration); 
        //TODO: converte coordinates back to coffee/original code
        var pos = this.$.editor.mirror.posFromIndex(id.declaration.range[0]);
        console.log("pos",pos)
        this.$.editor.addMarker(pos.line);

        //now select the instances in 3D view
        var type = id.declaration.name;
        this.selectedMesh = null;


        if(type in this.partInstancesByType)
        {
          var selectedMesh = this.selectedMesh;
          //selectedMesh = this.partInstancesByType[type].instances[0];

          for(var i=0; i< this.partInstancesByType[type].instances.length;i++)
          {
            var newSelection = this.partInstancesByType[type].instances[i];
            if(!(newSelection instanceof THREE.Object3D)) continue;
            this.currentSelections.push(newSelection);
            var outlineMaterial = new THREE.MeshBasicMaterial({
              color: 0xff0000,//0xffc200,
              side: THREE.BackSide
            });
            outline = new THREE.Mesh(newSelection.geometry, outlineMaterial);
            outline.name = "selectOutline";
            outline.scale.multiplyScalar(1.02);
            newSelection.outline = outline;
            newSelection.add(outline);
          }

        }
        
        //var code = context.rename(id, 'answer');
      }
    },
    
    editorChanged:function(event, detail, sender)
    {
      //console.log("sender",sender )
      //console.log("editorValue",sender.value )
      //console.log("editorValue2",sender.editorValue )//.templateInstance.model.impl.editorValue);
      //this.source = sender.editorValue;
      //console.log("this.source", this.source);
    },
  
    addSelectionEffect:function(oldSelection, newSelection)
    {
      this.selectionColor = 0xfffccc;
      //remove from old selection
      if(oldSelection != null)
      {
        oldSelection.remove(oldSelection.outline);
        oldSelection.cage = null;
        oldSelection.outline = null;
      }
      //add to new selection
      if(newSelection != null)
      {
          var outlineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,//0xffc200,
            side: THREE.BackSide
          });
          outline = new THREE.Mesh(newSelection.geometry, outlineMaterial);
          outline.name = "selectOutline";
          outline.scale.multiplyScalar(1.02);
          newSelection.outline = outline;
          newSelection.add(outline);
      }
    }
  
    });
    </script>
  </polymer-element>
  

  
<foo-editor> </foo-editor>

  

  <script>
    window.addEventListener('WebComponentsReady', function() {

      console.log("web components ready");
      document.body.style.opacity = 1; // show body now that registration is done.
	    //var aceEditor = document.querySelector('ace-element');
      //workaround for node-webkit 0.6.3      
      //aceEditor.style.opacity = 1;

    });
  </script>  
</body>
</html>
