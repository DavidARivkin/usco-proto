<link rel="import" href="../../components/polymer/polymer.html">
<link rel="import" href="../../components/usco-polymer-three-js/three-js.html">
<link rel="import" href="../shape-creator/shape-creator.html">

<link rel="import" href="./lib/grid-helper.html">

<link rel="import" href="../../components/usco-command-manager/usco-command-manager.html">
<script src="lib/commands.js"></script>

<script src="lib/transformControls.js"></script>

<polymer-element name="visual-editor" attributes="autorotate fullscreen axes xpos width depth height radius hue saturation darkness offset" 
on-mousewheel="{{onMouseWheel}}" on-DOMMouseScroll="{{onMouseWheel}}" >
  <template>
    <style>
      :host{
        display:block;
      }
      history-editor{
        display:block;
        position:absolute;
        color:black;
        z-index:2;
      }
      shape-creator{
        opacity : 0;
        z-index : 3;
      }
      three-js{
         /*display:inline-block;*/
         width: 100%;
         height:100%;
         position: absolute;
         z-index : 1;
      }

    </style>

    <shape-creator id="contextMenu"> </shape-creator>

    <history-editor id="historyEditor"> </history-editor>

    <three-js postProcess fullscreen="{{fullscreen}}" selectedObjects="{{selectedObjects}}" id="viewer" on-keyup="{{keyUp}}">
          <three-stats id="stats" show></three-stats>
          <three-js-combinedCamera tracking x="100" y="100" z="200" orientation="top" cameraUp=[0,0,1] ></three-js-combinedCamera>
          <three-js-orbitControls cameraUp=[0,0,1] autoRotateSpeed="10" autoRotate="{{autorotate}}"> </three-js-orbitControls>

          <three-js-scene name="mainScene" active>
            <three-js-object hierarchyRoot>
            </three-js-object>

            <three-js-object helpersRoot>
              <three-axis-helper show="{{axes}}"> </three-axis-helper>
              <grid-helper size="200" step="10" receiveShadow> </grid-helper>

              <three-js-light kind="ambient" color="0x161515" > </three-js-light>
              <three-js-light kind="hemi" color="0xffEEEE" secColor="0xffEEEE" intensity="0.2" > </three-js-light>
              <three-js-light kind="dir" color="0xffEEEE" intensity="0.2" shadow> </three-js-light> 
              <three-js-light kind="dir" color="0xfcfc7e" intensity="0.5" > </three-js-light>
              <three-js-light kind="dir" color="0xfcfc7e" intensity="0.5" > </three-js-light>
               
              <!--  pLight.position.set( 100, 150, 200 );   pLight.target.position.set(0,0,0);
                pLight2.position.set( 100, -150, 200 );
                  pLight2.target.position.set(0,0,0);
              -->

  
              <!--<three-js-light x="50" y="30" z="200"></three-js-light>
              <three-js-light kind="spot" x="-150" y="350" rx="90" shadow></three-js-light>-->
            </three-js-object>
          </three-js-scene>

          <three-effect-composer >
            <vignette-fx darkness="5" offset="0.4"> </vignette-fx>
          </three-effect-composer>
     </three-js>
  </template>
  <script>
    Polymer("visual-editor",{
    autorotate:false,
    selectedObjects:null,
    selectedObject:null,
    created:function()
    {
      this.selectedObjects=[];
    },
    enteredView:function()
    {
      this.viewer = this.$.viewer;
      this.commandManager = this.$.historyEditor;

      this.transformControls = new THREE.TransformControls(this.viewer.camera, this.$.viewer);
      this.transformControls.setMode( "translate" );
      this.viewer.updatables.push( this.transformControls.update ) ;

      function onControlsChange(event)
      {
          //console.log("pouet");
          this.viewer.controls.enabled = true;
          if(this.transformControls.axis != undefined)
          {
            this.viewer.controls.enabled = false;
          }
      }
      this.transformControls.addEventListener( 'change', onControlsChange.bind(this) )

      function onObjectTranform(event)
      {
        var operation = null;
        switch(event.transform)
        {
          case "rotate":
            //console.log("controls rotate",event.value);
            operation = new Rotation(event.value,this.selectedObject);
          break;
          case "translate":
            //console.log("controls translate",event.value);
            operation = new Translation(event.value,this.selectedObject);
          break;
          case "scale":
            //console.log("controls scale",event.value);
            operation = new Scaling(event.value,this.selectedObject);
          break;
        }
        
        if( operation != null)
        {
          this.commandManager.addCommand( operation );
          //hack, have not found a way to get a template instance (repeat) index, if there is one
          //operation.index = this.undos.length - 1;
        }
      }
      this.transformControls.addEventListener( 'transform', onObjectTranform.bind(this) )

      var sC = this.$.contextMenu; //document.querySelector('shape-creator');

      this.addEventListener('contextmenu',function(event){
        var event = event.impl || event;
        sC.enabled=true;
        sC.style.opacity = 1;
        sC.style.left = event.x;
        sC.style.top = event.y;
        event.preventDefault();
        return false;
      });

      this.addEventListener('click',function(event){
        sC.style.opacity = 0;
        sC.enabled=false;
      });
      this.addEventListener('reqShapeCreation',function(event, bla, bli){
        //console.log("shape creation request recieved", event, bla, bli);
        var type= event.detail.type;
        if(type)
        {
          //console.log("editor creating", type);
          var instance = null;
          switch(type)
          {
            case "Cube":
              var instance = new THREE.Mesh( new THREE.CubeGeometry( 20, 20, 20 ), new THREE.MeshBasicMaterial({color:0x00ff00}) );
            break;
            case "Sphere":
              var instance = new THREE.Mesh( new THREE.SphereGeometry( 10, 20, 20 ), new THREE.MeshBasicMaterial() );
            break;
            case "Cylinder":
              var instance = new THREE.Mesh( new THREE.CylinderGeometry( 10, 20, 20 ), new THREE.MeshBasicMaterial() );
            break;
            case "Part":
              //var instance = new THREE.Mesh();
            break;
          }
          
          if(instance!=null){
            instance.name = type;
            if(this.selectedObjects.length==1) //if we have a selection, add it to that selection
            {
             this.selectedObjects[0].add( instance ) ;
            }
            else
            {
              this.viewer.addToScene(instance);
            }
            this.commandManager.addCommand( new Creation(instance, instance.parent) );
          }
        }
    });
    },
    selectedObjectsChanged:function(oldSelections, newSelections)
    {
      var newSelections = this.selectedObjects;
      console.log("selection", newSelections,"old",oldSelections);
      
      if(!(oldSelections)) oldSelections = [];
      if(!(newSelections)) newSelections = [];
      if(oldSelections.length == 0 && newSelections.length == 0) { return }

      this.transformControls.detach();
      this.viewer.removeFromScene(this.transformControls);
      
      //remove from old
      for(var i=oldSelections.length-1;i>=0;i--)
      {
        var oldSelection = oldSelections[i];
        

        this.selectedObject.remove( oldSelection );
        oldSelection.position.add( this.selectedObject.position );
        this.viewer.addToScene( oldSelection );
        
        //oldSelection.controls = null;
        if(oldSelection.outline!=null)
        { 
          var outline = oldSelection.outline;
          oldSelection.remove(outline);
          delete oldSelection.outline;
        }
      }
      //add to new selection
      this.viewer.removeFromScene(this.selectedObject);
      if(newSelections.length>0)
      {
      this.selectedObject = new THREE.Object3D();//"group" object
      this.transformControls.attach( this.selectedObject ); 
      this.viewer.scene.add(this.transformControls);     
      this.viewer.addToScene(this.selectedObject);
      }
   
      var avgPosition = new THREE.Vector3();

      for(var i= newSelections.length-1 ;i>=0;i--)
      {
        var newSelection = newSelections[i];
        avgPosition.add( newSelection.position );
      }
      this.selectedObject.position = avgPosition;

      for(var i= newSelections.length-1 ;i>=0;i--)
      {
        var newSelection = newSelections[i];

        if(this.selectedObject)this.selectedObject.add( newSelection );

        //this.viewer.addToScene(this.transformControls);
        //console.log("this.viewer",this.viewer);
        //newSelection.controls = this.transformControls;

        if(newSelection.outline) continue;
        var outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,//0xffc200,
          side: THREE.BackSide
        });
        var outline = new THREE.Mesh(newSelection.geometry.clone(), outlineMaterial);
        outline.name = "selectOutline";
        outline.scale.multiplyScalar(1.03);
        newSelection.outline = outline;
        newSelection.add(outline);
      }
    },
    onMouseWheel:function (event)
    {
      //this blocks page scrolling if mouse is within this element
      event.preventDefault();
      return false;
    },
    keyUp:function(event)
    {
      var keyCode = event.impl.keyCode;
      var ctrlPressed = event.impl.ctrlKey;
      var shiftPressed= event.impl.shiftKey;

      if(keyCode == 46) //delete
		  {
        while((selectedObject=this.selectedObjects.pop()) != null){
          var parent = selectedObject.parent
          parent.remove(selectedObject);
          //TODO: need a more generic system to publish operation into the history
          this.commandManager.addCommand( new Deletion(selectedObject, parent) );
        }
		  }
    },

    //going down "one level" into an object hierarchy

    });
  </script>
</polymer-element>
