<link rel="import" href="../../components/polymer/polymer.html">
<link rel="import" href="../../components/polymer-localstorage/polymer-localstorage.html">
<link rel="import" href="../../components/polymer-signals/polymer-signals.html">

<link rel="import" href="../../components/usco-polymer-three-js/three-js.html">
<link rel="import" href="../shape-creator/shape-creator.html">
<link rel="import" href="../shape-creator/cube-creator.html">
<!--<link rel="import" href="../shape-creator/text-editor.html">-->
<link rel="import" href="../shape-creator/properties-editor.html">
<link rel="import" href="../shape-creator/generic-properties-editor.html">
<link rel="import" href="../mesh-exporter/mesh-exporter.html">

<link rel="import" href="./sub-elements/grid/grid-helper.html">
<!--<link rel="import" href="./sub-elements/fx/edgedetect-pass.html">
<link rel="import" href="./sub-elements/fx/outline-fx.html">
<link rel="import" href="./sub-elements/fx/depth-pass.html">
<link rel="import" href="./sub-elements/fx/normal-pass.html">
<link rel="import" href="./sub-elements/fx/copy-pass.html">
<link rel="import" href="./sub-elements/fx/render-pass.html">
<link rel="import" href="./sub-elements/fx/fsaa-pass.html">
<link rel="import" href="./sub-elements/fx/contrast-pass.html">

<link rel="import" href="./sub-elements/fx/test-fx.html">-->

<link rel="import" href="../../components/usco-command-manager/usco-command-manager.html">
<script src="lib/operations/commands.js"></script>
<script src="lib/operations/creation.js"></script>
<script src="lib/operations/deletion.js"></script>
<script src="lib/operations/import.js"></script>
<script src="lib/operations/clone.js"></script>

<script src="lib/operations/translation.js"></script>
<script src="lib/operations/rotation.js"></script>
<script src="lib/operations/scaling.js"></script>

<script src="lib/operations/union.js"></script>
<script src="lib/operations/subtraction.js"></script>
<script src="lib/operations/intersection.js"></script>

<script src="lib/operations/extrusion.js"></script>

<script src="lib/class-creator/class-creator.js"></script>




<script src="lib/transformControls.js"></script>
<script src="lib/shapes/THREECSG.js"></script>
<script src="lib/shapes/meshWrapper.js"></script>
<script src="lib/shapes/shapes.js"></script>
<script src="lib/shapes/shapes2d.js"></script>
<script src="lib/shapes/BufferGeometryUtils.js"></script>

<script src="lib/helpers/parent-child-links-helper.js"></script>
<script src="lib/helpers/linked-clone-helper.js"></script>
<script src="lib/helpers/computeBounding.js"></script>
<script src="lib/helpers/textDraw-helper.js"></script>
<script src="lib/helpers/object-dimensions-helper.js"></script>

<script src="lib/connectors/connector.js"></script>

<!--<script src="lib/materials/materialTest.js"></script>-->
<script src="lib/code-generation/code-generators.js"></script>
<script src="lib/code-generation/code-generation-ui.js"></script>


<script src="fonts/helvetiker_regular.typeface.js"></script>
<script src="fonts/fontawesome_regular.typeface_2.js"></script>

<link rel="import" href="../material-editor/material-editor.html">


<polymer-element name="visual-editor" attributes="autorotate fullscreen axes xpos width depth height radius hue saturation darkness offset" 
on-mousewheel="{{onMouseWheel}}" on-DOMMouseScroll="{{onMouseWheel}}" on-dragover="{{handleDragOver}}" on-drop="{{handleDrop}}"
>
  <template >
    <style>
      :host{
        display:block;
        position:absolute;
        width:640px;
        height:480px;
      }
      
      three-js{
         /*display:inline-block;*/
         z-index : 1;
         position: absolute;
        width: 100%;
         height:100%;
      }
      input[type="number"]{
        width:50px;
        size:3;
      }
    </style>
    
    <!--AutoSaving settings to localstorage-->
    <polymer-localstorage name="usco-proto-settings-showGrid"   value="{{showGrid}}"></polymer-localstorage>
    <polymer-localstorage name="usco-proto-settings-showAxes"   value="{{showAxes}}"></polymer-localstorage>
    <polymer-localstorage name="usco-proto-settings-autoRotate" value="{{autoRotate}}"></polymer-localstorage>

    <!--pub sub messages handling-->
    <polymer-signals on-polymer-signal-request-screenshot="{{makeScreenShot}}"></polymer-signals>

    <!-- for various "visual" settings-->
    <div style="position:absolute;left:30%;top:20px;z-index:9">
        <span> Cursor </span>
        Snap to grid <!--<input type="checkbox" checked="{{cursorSettings.snapToGrid}}"> </input>-->
        Snap transform <input type="checkbox" checked="{{cursorSettings.snapTransform}}"> </input>
        Translate step <input type="number" value="{{gridSettings.step}}" step=1 min=0.01 max=100></input>
        Rotate    step <input type="number" value="{{transformSettings.rotateStep}}" step=0.01 min=0.1 max=1 ></input>
        Scale     step <input type="number" value="{{transformSettings.scaleStep}}"  step=0.1 min=0.1 max=1></input>
    </div>    
    
    <shape-creator id="contextMenu"> </shape-creator>

    <!--testing editing of 2d shapes-->
    <div id="shapeEdit" class="shapeEdit" style="position:absolute; left:20px;top:300px;z-index:10">
      <div>
        <!--<properties-editor selection="{{selectedObject}}"> <properties-editor>-->
        <generic-properties-editor selection="{{selectedObject}}" style="z-index:999"> <generic-properties-editor>
      </div>
    </div>
    <mesh-exporter selection="{{selectedObject}}" hierarchyRoot="{{hierarchyRoot}}"> </mesh-exporter>

    <three-js postProcess fullscreen="{{fullscreen}}" 
    selectedObjects="{{selectedObjects}}" id="viewer" on-keydown="{{keyUp}}" on-sceneready="{{viewerSceneReady}}">
      <!--<drag-drop id="dragDropLayer"> </drag-drop>-->
          <three-stats id="stats" show></three-stats>
          <three-js-combinedCamera tracking x="100" y="100" z="200" orientation="top" cameraUp=[0,0,1] ></three-js-combinedCamera>
          <three-js-orbitControls cameraUp=[0,0,1] autoRotateSpeed="10" autoRotate="{{autorotate}}"> </three-js-orbitControls>

          <three-js-scene name="mainScene" active>
            <three-js-object hierarchyRoot>
            </three-js-object>

            <three-js-object helpersRoot>
              <three-axis-helper show="{{showAxes}}"> </three-axis-helper>
              <grid-helper show="{{showGrid}}" size="200" step="{{gridSettings.step}}" receiveShadow > </grid-helper>

              <three-js-light kind="dir" color="0xffEEEE" intensity="0.2" castShadow y=50 z=300 > </three-js-light> 
               <three-js-light kind="ambient" color="0x161515" intensity="0.8"> </three-js-light>
               <three-js-light kind="hemi" color="0xffffff" secColor="0xffffff" intensity="0.5" y="1200" z="5000"> </three-js-light>
              <!--
              <three-js-light kind="dir" color="0xfcfc7e" intensity="0.5" x=100 y=150 z=200> </three-js-light>
              <three-js-light kind="dir" color="0xfcfc7e" intensity="0.5" x=100 y=-150 z=200> </three-js-light>-->
            </three-js-object>
          </three-js-scene>

          <!--TODO: if no effects are added, effect composer/post process should deactivated -->
          <!--
          <three-effect-composer name="finalComposer" toScreen>
            <three-effect-composer name="normals" renderTarget2="{{normalRT}}">
              <normal-pass> </normal-pass>
              <edgeDetect-pass type=3> </edgeDetect-pass>
              <copy-pass></copy-pass>
            </three-effect-composer>
            
            <three-effect-composer name="depths" renderTarget2="{{depthRT}}">
              <depth-pass> </depth-pass>
              <edgeDetect-pass type=3> </edgeDetect-pass>
              <copy-pass> </copy-pass>
            </three-effect-composer>
            
            <render-pass> </render-pass>
            <vignette-fx darkness="5" offset="0.4"> </vignette-fx>
            <outline-fx tNormal="{{normalRT}}" tDepth="{{normalRT}}" color="{{outlineColor}}" strength="{{outlineStrength}}"> </outline-fx>  
            <fsaa-pass> </fsaa-pass>
            <copy-pass> </copy-pass>
          </three-effect-composer>
          -->
     </three-js>
  </template>
  <script>
    Polymer("visual-editor",{
    applyAuthorStyles: true,

    autorotate:false,
    showGrid:true,
    showAxes : false,
    showDimensions:true,

    //TODO move this to a structure
    hierarchyRoot:new Part(),
    //the root of the active editing level
    activeRoot:null,
    
    
    groupSelectionHelper: new THREE.Object3D(),
    selectedObjects:null,
    selectedObject:null,//first or single selection

    source:"//testing\n",
    altSource:"",
    
    gridSettings:{step:10},
    cursorSettings:{snapToGrid:false,snapTransform:true},
    transformSettings:{translateStep:10, rotateStep:45, scaleStep:0.1},
    
    
     observe: {
      'gridSettings.step': 'transformSettingsChanged',
      'transformSettings.rotateStep': 'transformSettingsChanged',
      'transformSettings.scaleStep': 'transformSettingsChanged',
      
      'selectedObject.sourceShape.position.x':'foo',
      'selectedObject.sourceShape.position.y':'foo',
      'selectedObject.sourceShape.position.z':'foo',
      
      //'selectedObjects':'selectionsChanged'
    },
    
    /*
    
    foo:function()
    {
      console.log("selected object position changed");
      if(this.ptrUp)
      {
        if(this.selectedObjects.length>0)
        {
          var offset = this.selectedObjects[0].sourceShape.position;
          operation = new Translation(offset,this.selectedObjects[0].sourceShape);
          this.fire('newOperation', {msg: operation});
          //this.transformControls.detach(this.selectedObjects[0]);
          //this.transformControls.attach(this.selectedObjects[0]);
        }
      }
    },
    onPointerDown:function()
    {
      this.ptrUp = false;
    },
    onPointerUp:function()
    {
       this.ptrUp = true;
    },*/
    
    transformSettingsChanged:function()
    {
      console.log("transformSettings changed");
      this.transformControls.setScaleSnap(this.transformSettings.scaleStep);
      //convert to radians
      var radians = this.transformSettings.rotateStep*Math.PI/180;
      this.transformControls.setRotateSnap(radians);
      this.transformControls.setSnap(this.gridSettings.step);
    },
    
    created:function()
    {
      this.selectedObjects = [];
      
      //TODO: move this where it should be
      if(window.webkitURL) window.URL = window.webkitURL;
      
      //default active level : root of hierarchy
      this.activeRoot = this.hierarchyRoot;
      
    },
    enteredView:function()
    {
      this.viewer = this.$.viewer;
      
      var self = this;
      this.addEventListener('selectionsAdded', function(e) {
        self.selectionsAdded(e.detail);
      });
      
      this.addEventListener('selectionsRemoved', function(e) {
        self.selectionsRemoved(e.detail);
      });
    },
     viewerSceneReady:function(event)
    {
      console.log("a scene is ready",event);
      this.async(this.setupElements);
    },
    setupElements : function()
    {
      this.transformControls = new THREE.TransformControls(this.viewer.camera, this.$.viewer);
      this.transformControls.setMode( "translate" );
      this.transformControls.setSpace("local");
      this.transformSettingsChanged();//FIXME do this more cleanly: set all snaps       
      
      this.viewer.updatables.push( this.transformControls ) ;

      var geometry = new THREE.Geometry();
      this.fakeCursor = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xFF0000, linewidth: 3 } ), THREE.Lines );
      this.viewer.addToScene( this.fakeCursor);
      
      this.viewer.addToScene( this.groupSelectionHelper);
      
      /*var points = [new THREE.Vector2(10,10), new THREE.Vector2(100,90) ,new THREE.Vector2(80,10)];
      var shape = new Shape2d();
      //shape.fromPoints(points);
			shape.moveTo(  80, 20 );
				shape.lineTo(  40, 80 );
				shape.lineTo( 120, 80 );
				shape.bezierCurveTo( 80,20,80,20,  80, 20 );
			this.viewer.addToScene( shape.generateRenderables() );*/
			/*
			var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', Float32Array, 2, 3);
      geometry.dynamic = true;

      var position = geometry.attributes.position;
      position.needsUpdate = true;

      var p = position.array;

      var i = 0;
      p[i++] = 0;
      p[i++] = 0;
      p[i++] = 0;
      p[i++] = 20;
      p[i++] = 20;
      p[i] = 20;

      var color = new THREE.Color();
      color.g = color.b = 1 - this.value;

      var material = new THREE.LineBasicMaterial({
        color: color.getHex(),
        linewidth: 5 // THIS DON'T WORKS IN WINDOWS?
      });

      var model = new THREE.Line(geometry, material);
			this.viewer.addToScene( model );*/
			
			
      function onControlsChange(event)
      {
          this.viewer.controls.enabled = true;
          if(this.transformControls.axis != undefined)
          {
            this.viewer.controls.enabled = false;
          }
          
        if(event.target.object.name == "Shape2dPointHelper")
        {
          if(this.selectedObjects.length>0 && this.selectedObjects[0].parent.sourceElement)
          {
            this.selectedObjects[0].parent.sourceElement.update();
          }
        }
        //FIXME: horrible hack !!! transform is not always a translation!!
        if(this.selectedObjects[0].standInFor){
          this.selectedObjects[0].dispatchEvent({type:'translated',value:event.value});
        }
      }
      this.transformControls.addEventListener( 'change', onControlsChange.bind(this) )

      function onObjectTranform(event)
      {
        console.log("object transforming",event.target.object.name);
        if(event.target.object.name == "Shape2dPointHelper")
        {
          if(this.selectedObjects.length>0 && this.selectedObjects[0].parent.sourceElement)
          {
            this.selectedObjects[0].parent.sourceElement.update();
          }
        }
        
        var operation = null;
        switch(event.transform)
        {
          case "rotate":
            operation = new Rotation(event.value,this.selectedObjects[0].sourceShape);
          break;
          case "translate":
            if(this.selectedObjects[0].standInFor){
              this.selectedObjects[0].dispatchEvent({type:'translated',value:event.value});
            }
            //operation = new Translation(event.value,this.selectedObjects[0].sourceShape);
            
            op = this.selectedObjects[0].sourceShape.translate( event.value );
            //console.log("object translated", this.selectedObjects[0].sourceShape )
            this.activeRoot.operations.push( op );
            
          break;
          case "scale":
            operation = new Scaling(event.value,this.selectedObjects[0]);
          break;
        }
        
        if( operation != null)
        {
          //this.fire('newOperation', {msg: operation});
        }
      }
      this.transformControls.addEventListener( 'transform', onObjectTranform.bind(this) )

      var sC = this.$.contextMenu; //document.querySelector('shape-creator');
      var self = this;
      this.addEventListener('contextmenu',function(event){
        var event = event.impl || event;
        sC.enabled=true;
        sC.style.opacity = 1;
        sC.style.left = event.x;
        sC.style.top = event.y;
        self.viewer.controls.enabled = false;
        self.transformControls.enabled = false;
        event.preventDefault();
        return false;
      });
      this.contextMenu = sC;


      this.viewer.addEventListener('click',function(event){
        if(sC.enabled)
        {
        sC.style.opacity = 0;
        sC.enabled=false;
        self.viewer.controls.enabled = true;
        self.transformControls.enabled = true;
        }
      });
      this.addEventListener('reqShapeCreation',function(event){
        var type= event.detail.type;
        if(type)
        {
          var instance = null;
          var options = {};
          switch(type)
          {
            case "Cube":
              //options = {w:this.cubeWidth,d:this.cubeDepth,h:this.cubeHeight};
              instance = new Cube(options);
              //this.$.cubeEditor.target = instance;
              instance.generateRenderables();
              //this.viewer.addToScene( instance.generateRenderables() );
            break;
            case "Sphere":
              instance = new Sphere(options);
              instance.generateRenderables();
              //this.$.sphereEditor.target = instance;
            break;
            case "Cylinder":
              instance = new Cylinder(options);
              instance.generateRenderables();
            break;
            case "Torus":
              instance = new Torus(options);
              instance.generateRenderables();
            break;
            case "Part":
              //var instance = new THREE.Mesh();
            break;
            case "Connector":
              instance = new Connector();
            break;
            
            case "Rectangle":
              instance = new Rectangle();
              instance.generateRenderables();
            break;
            
            case "Circle":
              instance = new Circle();
              instance.generateRenderables();
            break;
    
            case "Polyline":
            
            break;
            
            case "Text":
              //options = {text:this.testText,font:this.textFont,size:this.textSize};
              //options = {text:"\uf112",font:'fontawesome',size:20};
              instance = new Text({});
              instance.generateRenderables();
              
            break;
          }
          
          if(instance!=null){
            instance.name = type;
            instance.castShadows=true;
            instance.recieveShadows = true;

            /*
            if(!(instance instanceof Shape2d))
            {
              geometry = instance.geometry;
              geometry.verticesNeedUpdate = true;
              geometry.normalsNeedUpdate = true;
              geometry.uvsNeedUpdate = true;
              geometry.computeCentroids();
              geometry.computeFaceNormals();
              geometry.computeVertexNormals();
              geometry.computeMorphNormals();
              geometry.computeTangents();
            }*/
            if(this.selectedObjects.length==1) //if we have a selection, add it to that selection
            {
             this.selectedObjects[0].add( instance ) ;
             instance.position.x +=30;
            }
            else
            {
              if(instance.renderable)
              {
                this.viewer.addToScene(instance.renderable);
                this.selectedObjects=[instance.renderable];
              }
            }
            this.hierarchyRoot.add( instance );
            this.fire('newOperation', {msg: new Creation(instance, instance.parent, options)});
          }
        }
     });
     
     this.addEventListener('reqShapeOperation',function(event){
        var type= event.detail.type;
        var selections = this.selectedObjects;

        function union(selections)
        {
          if(selections.length == 0) return;
          var operands = selections.slice(1);
          var result = selections[0].union( operands ); 
        }

        function subtract(selections)
        {
          if(selections.length == 0) return;
          var operands = selections.slice(1);
          for(var i=0; i<operands.length;i++)
          {
            operands[i].parent.remove( operands[i] );
            //FIXME:should we or should we not delete right hand operands?
            operands[i] = operands[i].sourceShape;
          }
          var result = selections[0].sourceShape.subtract( operands ); 
        }
        function intersect(selections)
        {
          if(selections.length == 0) return;
          var operands = selections.slice(1);
          var result = selections[0].intersect( operands ); 
        }

        if(type)
        {
          var result = null;
          var operation = null;
          switch(type)
          {
            case 'export':
              var target = selections[0].sourceShape;
              this.asyncFire('export-requested', {format:this.exportFormat,data:target} );
              return;
            break;
          
            case 'union':
              var target = selections[0];
              var oldGeometry = target.geometry.clone();

              result = union( selections );
              operation = new Union(target, oldGeometry, selections.slice(1));
            break;
            case 'subtract':
              var target = selections[0];
              var oldGeometry = target.geometry.clone();

              result = subtract(selections);
              operation = new Subtraction(target, oldGeometry, selections.slice(1) ) ;
            break;
            case 'intersect':
              var target = selections[0];
              var oldGeometry = target.geometry.clone();

              result = intersect(selections);
              operation = new Intersection(target, oldGeometry, selections.slice(1)) ;
            break;

            //specials
            case 'mirrorX':
              var mesh = selections[0].parent.parent;
              var geometry = mesh.innerMesh.geometry;
              console.log("v",geometry);

               var mS = (new THREE.Matrix4()).identity();
                mS.elements[0] = -1;//flip x

              var mat = new THREE.Matrix4().makeScale(-1, 1, 1);
              geometry.applyMatrix(mat);
              mesh.innerMesh.applyMatrix( mat );

              geometry.verticesNeedUpdate = true;
	            geometry.elementsNeedUpdate = true;
	            geometry.normalsNeedUpdate = true;
                //mesh.flipSided = true;

                for(var i = 0; i<geometry.faces.length; i++) {
                    geometry.faces[i].normal.x = -1*geometry.faces[i].normal.x;
                   geometry.faces[i].normal.y = -1*geometry.faces[i].normal.y;
                    geometry.faces[i].normal.z = -1*geometry.faces[i].normal.z;
                }
                geometry.computeVertexNormals();
                geometry.computeFaceNormals();
              mesh.innerMesh.material.side = THREE.DoubleSide;
              
            break;
            
            case 'extrude':
              var shape = selections[0].sourceElement
              var extrudeSettings = {};
              extrudeSettings.bevelEnabled = false;
				      extrudeSettings.bevelSegments = 2;
				      extrudeSettings.steps = 2;
				      extrudeSettings.amount = 20;
              var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

					    var mesh = new Part();
					    mesh.name = "Part";
					    mesh.geometry = geometry;
					    renderable = mesh.generateRenderables();
					    
					    result = renderable;
					  break;
              
            case 'clone':
              var newInstance = selections[0].sourceShape.clone();
              result = newInstance.generateRenderables();
              
              this.hierarchyRoot.add( result.sourceShape );
              this.viewer.addToScene( result );
          
              operation = new Clone(result.sourceShape);
              this.fire('newOperation', {msg: operation});
              this.selectedObjects = [result];//make sure the new item is the selected one
              return;
            break;

            case 'linkedClone':
              selections[0].remove(selections[0].outline)
              var original = selections[0].parent.parent;
              result = original.clone();
              selections[0].add(selections[0].outline);

              //for visual helpers
              original.innerMesh.lClones = [result];
              result._original = original;

              result.name = original.name+"linkedClone";
              original.addEventListener('shapeChanged',function(event){});
            break;
            
            case 'templatize':
              //TODO add a custom editor for this where you can specify stuff
              
              className = "FooPart";
              var newClass = createCustomPartClass( className, this.selectedObjects );
              var instance = new newClass();
              
              instance.execute();
              instance.generateRenderables();
              console.log("custom class instance:\n", result);
              
              for(var i=0;i<this.selectedObjects.length;i++)
              {
               //?????
               var select = this.selectedObjects[i];
               //TODO: remove its history too !
               select.sourceShape.parent.remove( select.sourceShape );
               select.parent.remove( select );
              }
              
              //TODO: after we created our custom class, (see ClassDeclaration, esprima )
              //we REMOVE all the selectedObjects from our CURRENT editing scope (CES)
              //we INSTANCIATE an instance of the new class 
              //we add it to our CES
              
              if(instance.renderable)
              {
                this.viewer.addToScene(instance.renderable);
                this.selectedObjects=[instance.renderable];
              }
              this.hierarchyRoot.add( instance );
              
              
              
            break;
            
          }

          {
            this.fire('newOperation', {msg: operation});
            return;
          }
          if(type == 'mirrorX')
          {
          }
          if(type == 'extrude')
          {
            this.viewer.addToScene( result );
            var operation = new Extrusion(result, extrudeSettings, shape, result.parent);
            this.fire('newOperation', {msg: operation});
            this.selectedObjects = [result];//make sure the new item is the selected one
          }
          else{
          console.log("adding to scene",result);
          this.hierarchyRoot.add( result.sourceShape );
          this.viewer.addToScene( result );
          
          operation = new Creation(result.sourceShape, result.sourceShape.parent);
          this.fire('newOperation', {msg: operation});
          this.selectedObjects = [result];//make sure the new item is the selected one
          }
        }
    });
    },
    computeAvgPos : function()
    {
      var selections = this.selectedObjects;
      var avgPosition = new THREE.Vector3();
      console.log("this.groupSelectionHelper.position",this.groupSelectionHelper.position);
      
      if(selections.length>0)
      {
        avgPosition= selections[selections.length-1].position.clone();
        for(var i= selections.length-2 ;i>=0;i--)
        {
          var selection = selections[i];
          avgPosition.add( selection.position );
        }
        avgPosition.divideScalar( selections.length );
      }
      //console.log("avgposFinal", avgPosition);
      //this.groupSelectionHelper.position = avgPosition;
      //console.log("this.groupSelectionHelper.position",this.groupSelectionHelper.position);
      console.log("avgPosition",avgPosition);
      //this.transformControls.position = avgPosition;
      
      
      return avgPosition;
    },
    selectionsAdded:function(addedSelections)
    {
      console.log("selections added",addedSelections);
      var groupSelectionHelper = this.groupSelectionHelper;
      
     // console.log("this.groupSelectionHelper.position",this.groupSelectionHelper.position);
      this.computeAvgPos();
      for(var i=0;i<addedSelections.length;i++)
      {
        var newSelection = addedSelections[i];
        //if(!(newSelection)) continue;
        /*for(var j=0;j<this.groupSelectionHelper.children.length;j++)
        {
          this.groupSelectionHelper.children[j].position = new THREE.Vector3();
        }*/
        
        //this.groupSelectionHelper.add( newSelection );
        
        //console.log("newSelection.pos",newSelection.position,"this.groupSelectionHelper.position",this.groupSelectionHelper.position);
        //newSelection.position.sub( this.groupSelectionHelper.position );
        //console.log("newSelection.pos",newSelection.position,"this.groupSelectionHelper.position",this.groupSelectionHelper.position);
      
        if(newSelection.outline) continue;
        var outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,//0xffc200,
          side: THREE.BackSide
        });
        var outline = new THREE.Mesh(newSelection.geometry.clone(), outlineMaterial);
        outline.name = "selectOutline";
        outline.scale.multiplyScalar(1.03);
        newSelection.outline = outline;
        newSelection.add(outline);
      }
            //this.computeAvgPos();
      //TODO:refactor
      /*if(this.showDimensions)
      {
        var objDims = new ObjectDimensionsHelper({mesh:groupSelectionHelper});
        groupSelectionHelper.add( objDims );
        if(!(groupSelectionHelper.helpers)) groupSelectionHelper.helpers = {}
        groupSelectionHelper.helpers.dims = objDims;
      }*/
      
    },
    selectionsRemoved:function(removedSelections)
    {
      console.log("selections removed",    removedSelections);
      //console.log("this.groupSelectionHelper.position",this.groupSelectionHelper.position);
      for(var i=0;i<removedSelections.length;i++)
      {
        var oldSelection = removedSelections[i];
        //this.viewer.addToScene( oldSelection );
        //oldSelection.position.add( this.groupSelectionHelper.position );
        
        if(oldSelection.outline!=null)
        { 
          var outline = oldSelection.outline;
          oldSelection.remove(outline);
          delete oldSelection.outline;
        }
      }
      this.computeAvgPos();
      if(this.selectedObjects.length == 0)
      {
        var groupSelectionHelper = this.groupSelectionHelper;
        groupSelectionHelper.position = new THREE.Vector3();
        if(this.showDimensions && groupSelectionHelper.helpers)
        {
          var dims = groupSelectionHelper.helpers.dims;
          if(dims)
          {
            groupSelectionHelper.remove(dims);
            groupSelectionHelper.helpers.dims = null;
          }
        }         
               
      }

      
      //console.log("this.groupSelectionHelper.position",this.groupSelectionHelper.position);
    },
    selectedObjectsChanged:function(oldSelections, newSelections, foo, bar)
    {
      //console.log("old", oldSelections,"new", newSelections, foo, bar);
      var newSelections = this.selectedObjects;
      //console.log("selections : new", newSelections,"old",oldSelections);
      
      if(!(oldSelections)) oldSelections = [];
      if(!(newSelections)) newSelections = [];
      if(oldSelections.length == 0 && newSelections.length == 0) {  this.contextMenu.target = '';this.contextMenu.mode = 'creation';    this.transformControls.detach(); return; }


      var selectedObject = this.selectedObject = newSelections[0];

      if(this.selectedObjects.length==0)
      {
        this.transformControls.detach();
        this.viewer.removeFromScene(this.transformControls);
      }
      if(this.selectedObjects.length>0)
      {
        this.viewer.scene.add(this.transformControls);
        this.transformControls.attach( this.selectedObjects[0]  );  //this.groupSelectionHelper
      }
   
      if(newSelections.length>0)
      {
        this.contextMenu.mode = 'operations';
        this.contextMenu.target = '';
        
        if(newSelections && newSelections[0].sourceElement instanceof Shape2d)
        {
          this.contextMenu.target = 'shape2d';
        }
      }
      else
      {
        this.contextMenu.target = '';
        this.contextMenu.mode = 'creation';
      }
    },
    onMouseWheel:function (event)
    {
      //this blocks page scrolling if mouse is within this element
      event.preventDefault();
      return false;
    },
    keyUp:function(event)
    {
      var keyCode = event.impl.keyCode;
      var ctrlPressed = event.impl.ctrlKey;
      var shiftPressed= event.impl.shiftKey;

      switch(keyCode)
      {
        case 67://c
          
        break;
      
        case 68://d
          if(ctrlPressed){
            this.fire("reqShapeOperation",{type:"clone"});
            console.log("duplicating");
            event.preventDefault();
          }
        break;
        case 71://g
          if(this.transformControls.space == "world") this.transformControls.setSpace("local");
          if(this.transformControls.space == "local") this.transformControls.setSpace("world");
        break;
        case 82://r
          console.log("set to rotate");
          this.transformControls.setMode("rotate");
        break;
        case 83:
          if(ctrlPressed)
          {
            console.log("wanna save?");
            event.preventDefault();
          return false;
          }
          console.log("set to scale");
          this.transformControls.setMode("scale");
          break;
        case 84:
          console.log("set to translate");
          this.transformControls.setMode("translate");
        case 90:
          if(ctrlPressed && shiftPressed) {//ctrl+shift+z
            this.asyncFire("redoOperation",{});
            return;
          } 
          if(ctrlPressed)//ctrl+z was typed.
          {
            this.asyncFire("undoOperation",{});
            return;
          }
          break; 
        case 46:
          while((selectedObject=this.selectedObjects.pop()) != null){
            var parent = selectedObject.parent
            parent.remove(selectedObject);
            //TODO: need a more generic system to publish operation into the history
            var operation = new Deletion(selectedObject, parent);
            this.fire('newOperation', {msg: operation});
            
            if(selectedObject.dispatchEvent)selectedObject.dispatchEvent({type:'deleted'});
            
            this.selectedObjects = [];
          }
        break;
      }

    },
  handleDragOver:function(e) {
    if (e.preventDefault) {
      e.preventDefault();
    }
  },
  handleDrop:function(e)
  {
    if (e.preventDefault) {
      e.preventDefault(); // Necessary. Allows us to drop.
    }

    var data=e.dataTransfer.getData("Text");
    if(data)
    {
        this.asyncFire('text-dropped', {data:data} );
    }

    var files = e.dataTransfer.files;
    if(files)
    {
      this.asyncFire('files-dropped', {data:files});
    }
  } ,
  //pub sub mesages handling
  makeScreenShot:function()
  {
    console.log("fmkklm");
    function callback(data)
    {
      console.log("got screenshot data",data);
      var fileName = "usco-screenshot.png";
      var format = "png";
      
      var link = document.createElement("a");
      //var blob = new Blob([data],{type : 'image/'+format})
      //var url =  window.URL.createObjectURL(blob);
      //var blobURL = window.webkitURL.createObjectURL(blob);
      link.href = data;
      link.download = fileName;
      link.click();
      
    }
    this.viewer.captureScreen(callback, window.innerWidth, window.innerHeight)
  },
  
  //TODO: temp hack, down the line, parsers should return the correct types directly
  //TODO how to handle errors, as we are in a deferred's success callback
  addImportedResource: function( resource )
  {
    //if(resource.data instanceof THREE.Geometry) console.log("geometry, groovy!");
    var self = this;
    
    function createImportedFromGeometry(geometry, resource)
      {
        var importedPart = new Part();
        importedPart.geometry = geometry;//THREE.BufferGeometryUtils.fromGeometry( geometry ); //
        importedPart.name = resource.name;
        
        self.hierarchyRoot.add( importedPart );
        self.viewer.addToScene( importedPart.generateRenderables() );
        self.selectedObjects = [importedPart];
        operation = new Import(importedPart, resource);
        self.fire('newOperation', {msg: operation});
      }
      
      function createImported(importedPart, resource)
      {
        importedPart.name = resource.name;
        self.hierarchyRoot.add( importedPart );
        self.viewer.addToScene( importedPart.generateRenderables() );
        self.selectedObjects = [importedPart.renderable];
        operation = new Import(importedPart, resource);
        self.fire('newOperation', {msg: operation});
      }
    
    
    var importRoot = resource.data;
    if('children' in importRoot)
    {
      var importedPart=null;
      
      function getChildrenData(current, parent)
      {
        var rootPart = new Part();
        rootPart.name = current.name;
        rootPart.position = current.position;
        rootPart.rotation = current.rotation;
        rootPart.scale    = current.scale;
        rootPart.matrix   = current.matrix;
        rootPart.matrixWorld   = current.matrixWorld;
        rootPart._rotation = current._rotation ;
	      rootPart._quaternion = current._quaternion;
	      
	      rootPart._rotation._quaternion = current.quaternion;
	      rootPart._quaternion._euler = current.rotation;
        
        
        if(current instanceof THREE.Mesh) 
        {
          var geometry = current.geometry;
          computeVertexUvs( geometry);
          rootPart.geometry = geometry;//THREE.BufferGeometryUtils.fromGeometry( geometry );
          
        }
        if(parent) parent.add( rootPart );
        
        for(var i=0;i<current.children.length;i++)
        {
          var child = current.children[i];
          getChildrenData(child, rootPart);
        }
        return rootPart;
      }
      
      importedPart = getChildrenData(importRoot,null);
      
      function computeVertexUvs(geometry)
      {
        for(var i=0;i<geometry.faces.length;i++)
        {
          var face = geometry.faces[i];
          //hack
          geometry.faceVertexUvs[0].push([
          new THREE.Vector2(), //new THREE.Vector2( ( v1.x + offset.x ) / range.x , ( v1.y + offset.y ) / range.y ),
          new THREE.Vector2(),//new THREE.Vector2( ( v2.x + offset.x ) / range.x , ( v2.y + offset.y ) / range.y ),
          new THREE.Vector2(),//new THREE.Vector2( ( v3.x + offset.x ) / range.x , ( v3.y + offset.y ) / range.y )
        ]);
        }
        
        var autoCenter = false;
        geometry.computeBoundingSphere();
        if( autoCenter)
        {
          var offset = geometry.boundingSphere.center;
          geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -offset.x, -offset.y, -offset.z ) );
        }
        
     }
     createImported(importedPart, resource);
      
    }else
    {
      var geometry = importRoot;
      for(var i=0;i<geometry.faces.length;i++)
      {
        var face = geometry.faces[i];
         geometry.faceVertexUvs[0].push([
          new THREE.Vector2(), //new THREE.Vector2( ( v1.x + offset.x ) / range.x , ( v1.y + offset.y ) / range.y ),
          new THREE.Vector2(),//new THREE.Vector2( ( v2.x + offset.x ) / range.x , ( v2.y + offset.y ) / range.y ),
          new THREE.Vector2(),//new THREE.Vector2( ( v3.x + offset.x ) / range.x , ( v3.y + offset.y ) / range.y )
        ]);
      }
      
      geometry = updateGeometry( geometry);
      createImportedFromGeometry(geometry, resource);
    }
      
      function updateGeometry( geometry)
      {
        geometry.computeBoundingBox();
		    geometry.computeCentroids();
		    geometry.computeBoundingSphere();
		  
		    //centering hack
		    var autoCenter = false;
        if( autoCenter)
        {
          var offset = geometry.boundingSphere.center;
          geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -offset.x, -offset.y, -offset.z ) );
        }
        //needed at least for .ply files
        geometry.computeVertexNormals();
        geometry.computeFaceNormals();
        
        return geometry;
      }
  }
  
    //going down "one level" into an object hierarchy
    });
  </script>
</polymer-element>
