<link rel="import" href="../../components/polymer/polymer.html">
<link rel="import" href="../../components/polymer-localstorage/polymer-localstorage.html">

<link rel="import" href="../../components/usco-polymer-three-js/three-js.html">
<link rel="import" href="../shape-creator/shape-creator.html">

<link rel="import" href="./sub-elements/grid-helper.html">
<link rel="import" href="./sub-elements/drag-drop.html">

<link rel="import" href="../../components/usco-command-manager/usco-command-manager.html">
<script src="lib/operations/commands.js"></script>
<script src="lib/operations/creation.js"></script>
<script src="lib/operations/deletion.js"></script>
<script src="lib/operations/translation.js"></script>
<script src="lib/operations/rotation.js"></script>
<script src="lib/operations/scaling.js"></script>
<script src="lib/operations/union.js"></script>
<script src="lib/operations/subtraction.js"></script>
<script src="lib/operations/intersection.js"></script>
<script src="lib/operations/import.js"></script>

<script src="lib/transformControls.js"></script>
<script src="lib/shapes/THREECSG.js"></script>
<script src="lib/shapes/meshWrapper.js"></script>
<script src="lib/shapes/shapes.js"></script>

<script src="lib/helpers/parent-child-links-helper.js"></script>
<script src="lib/helpers/linked-clone-helper.js"></script>

<script src="lib/connectors/connector.js"></script>

<!--<script src="lib/materials/materialTest.js"></script>-->
<script src="lib/code-generation/code-generators.js"></script>
<script src="lib/code-generation/code-generation-ui.js"></script>

<link rel="import" href="../../components/code-mirror/code-mirror.html">

<polymer-element name="visual-editor" attributes="autorotate fullscreen axes xpos width depth height radius hue saturation darkness offset" 
on-mousewheel="{{onMouseWheel}}" on-DOMMouseScroll="{{onMouseWheel}}" on-dragover="{{handleDragOver}}" on-pointermove="{{ptrMove}}">
  <template >
    <style>
      :host{
        display:block;
        position:absolute;
        width:640px;
        height:480px;
      }

      #codeGen{
        position: absolute;
        right: 10px;
        top: 20px;
        z-index: 3;
      }

      shape-creator{
        opacity : 0;
        z-index : 4;
      }
      history-editor{
         z-index:3;
        display:block;
        position:absolute;
        color:black;
        padding:5px;
        height:100%;
        width:200px
      }
      #commandsHistory{
        height:100%;
        overflow:auto;
      }

      drag-drop{
        z-index:2;
        display:block;
        position:absolute;
        width: 100%;
        height:100%
      }
      three-js{
         /*display:inline-block;*/
         z-index : 1;
         position: absolute;
        width: 100%;
         height:100%;
      }

      code-mirror{position:absolute;top:80px;right:20px;width:400px;height:200px;z-index:9999;}

    </style>
    <!--AutoSaving settings to localstorage-->
    <polymer-localstorage name="usco-proto-settings-showGrid"   value="{{showGrid}}"></polymer-localstorage>
    <polymer-localstorage name="usco-proto-settings-showAxes"   value="{{showAxes}}"></polymer-localstorage>
    <polymer-localstorage name="usco-proto-settings-autoRotate" value="{{autoRotate}}"></polymer-localstorage>

    <!--various helpers-->
    <div id="codeGen" class="codeGen" style="position:absolute; right:10px;top:30px;z-index:3">
      <button on-click="{{generateCodeFromHistory}}"> Generate code from history </button>
      <button on-click="{{generateFromCode}}"> Generate shapes from code </button>
    </div>
    <shape-creator id="contextMenu"> </shape-creator>
    <history-editor id="historyEditor"> </history-editor>
    <!--<drag-drop id="dragDropLayer"> </drag-drop>-->

    <code-mirror id="selectEdit" theme="monokai" mode="javascript" value="{{source}}" >
    </code-mirror>

    <three-js postProcess fullscreen="{{fullscreen}}" 
    selectedObjects="{{selectedObjects}}" id="viewer" on-keydown="{{keyUp}}" on-sceneready="{{viewerSceneReady}}">
      <!--<drag-drop id="dragDropLayer"> </drag-drop>-->
          <three-stats id="stats" show></three-stats>
          <three-js-combinedCamera tracking x="100" y="100" z="200" orientation="top" cameraUp=[0,0,1] ></three-js-combinedCamera>
          <three-js-orbitControls cameraUp=[0,0,1] autoRotateSpeed="10" autoRotate="{{autorotate}}"> </three-js-orbitControls>

          <three-js-scene name="mainScene" active>
            <three-js-object hierarchyRoot>
            </three-js-object>

            <three-js-object helpersRoot>
              <three-axis-helper show="{{showAxes}}"> </three-axis-helper>
              <grid-helper       show="{{showGrid}}"size="200" step="10" receiveShadow> </grid-helper>

              <three-js-light kind="dir" color="0xffEEEE" intensity="0.2" castShadow y=50 z=300 > </three-js-light> 
               <three-js-light kind="ambient" color="0x161515" intensity="0.8"> </three-js-light>
               <three-js-light kind="hemi" color="0xffffff" secColor="0xffffff" intensity="0.5" y="1200" z="5000"> </three-js-light>
              <!--
              <three-js-light kind="dir" color="0xfcfc7e" intensity="0.5" x=100 y=150 z=200> </three-js-light>
              <three-js-light kind="dir" color="0xfcfc7e" intensity="0.5" x=100 y=-150 z=200> </three-js-light>-->
            </three-js-object>
          </three-js-scene>

          <!--TODO: if no effects are added, effect composer/post process should deactivated -->
          <!--<three-effect-composer>
            <vignette-fx darkness="5" offset="0.4"> </vignette-fx>
          </three-effect-composer>-->
     </three-js>
  </template>
  <script>
    Polymer("visual-editor",{
    applyAuthorStyles: true,

    autorotate:false,
    showAxes : false,
    selectedObjects:null,
    selectedObject:null,

    source:"//testing\n",
    ready:function()
    {
      //console.log("i am ready");
    },
    viewerSceneReady:function(event)
    {
      console.log("a scene is ready",event);
      this.async(this.setupElements);
    },
    created:function()
    {
      this.selectedObjects = [];
    },
    //generation of code based on history
    generateCodeFromHistory:function()
    {
       console.log("generating code from history");
       this.source = updateSelectionCode(this.selectedObject,this.commandManager.undos);
       console.log("res source", this.source);
    },
    generateFromCode:function()
    {
      //this.source.
    },
    //pointer movement and tracking of object normals
    ptrMove:function(event)
    {
      return;
      var event = event.impl || event;
        event = normalizeEvent(event);
        var x = event.offsetX;
        var y = event.offsetY;

      this.projector = new THREE.Projector();
    	var	v = new THREE.Vector3((x / this.viewer.width) * 2 - 1, -(y / this.viewer.height) * 2 + 1, 1);
      this.projector.unprojectVector(v, this.viewer.camera);
		  var raycaster = new THREE.Raycaster(this.viewer.camera.position, v.sub(this.viewer.camera.position).normalize());
     
		  var intersects = raycaster.intersectObjects(this.viewer.hierarchyRoot.children, true);
      if (intersects.length > 0) {
        var inter = intersects[0];
        if(!(inter.face)) return;
        var face = inter.face;
        var normal = inter.face.normal;
        var object = inter.object;

        var normalMatrix = new THREE.Matrix3().getNormalMatrix( object.matrixWorld );
        var worldNormal = normal.clone().applyMatrix3( normalMatrix ).normalize().multiplyScalar(50);

        var geometry = new THREE.Geometry();
        var start = inter.point.clone();
        var end   = inter.point.clone().add( worldNormal );

        delete this.fakeCursor.__webglInit;
        geometry.vertices.push( start );
        geometry.vertices.push( end );
        this.fakeCursor.geometry.dispose();
        this.fakeCursor.geometry = geometry;

        /*var tmp = new THREE.Mesh(new THREE.CubeGeometry(3,3,3), new THREE.MeshBasicMaterial({color:0xFF0000}));
        tmp.position = inter.point.clone();
        this.viewer.addToScene( tmp );*/
      }
      
    },
    enteredView:function()
    {
      this.viewer = this.$.viewer;
      this.commandManager = this.$.historyEditor;
    },
    setupElements : function()
    {
      console.log("viewer cam", this.viewer.camera);
      this.transformControls = new THREE.TransformControls(this.viewer.camera, this.$.viewer);
      this.transformControls.setMode( "translate" );
      this.transformControls.setSpace("local");
      this.transformControls.setSnap(10);
      this.viewer.updatables.push( this.transformControls.update ) ;

      var geometry = new THREE.Geometry();
      this.fakeCursor = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xFF0000, linewidth: 3 } ), THREE.Lines );
      this.viewer.addToScene( this.fakeCursor);


      function onControlsChange(event)
      {
          if( this.selectedObjects.length>0 && this.selectedObjects[0].lClones || this.selectedObjects[0].parent.parent._original)
          {
            if( this.selectedObjects[0].cloneLink) this.selectedObjects[0].remove( this.selectedObjects[0].cloneLink );
            drawLinkToLinkedClones(this.selectedObjects[0]);
          }
          this.viewer.controls.enabled = true;
          if(this.transformControls.axis != undefined)
          {
            this.viewer.controls.enabled = false;
          }
      }
      this.transformControls.addEventListener( 'change', onControlsChange.bind(this) )

      function onObjectTranform(event)
      {
        var operation = null;
        switch(event.transform)
        {
          case "rotate":
            operation = new Rotation(event.value,this.selectedObjects[0]);
          break;
          case "translate":
            operation = new Translation(event.value,this.selectedObjects[0]);
          break;
          case "scale":
            operation = new Scaling(event.value,this.selectedObjects[0]);
          break;
        }
        
        if( operation != null)
        {
          this.commandManager.addCommand( operation );
          //operation.index = this.undos.length - 1;
        }
      }
      this.transformControls.addEventListener( 'transform', onObjectTranform.bind(this) )

      var sC = this.$.contextMenu; //document.querySelector('shape-creator');
       var self = this;
      this.addEventListener('contextmenu',function(event){
        var event = event.impl || event;
        sC.enabled=true;
        sC.style.opacity = 1;
        sC.style.left = event.x;
        sC.style.top = event.y;
        self.viewer.controls.enabled = false;
        self.transformControls.enabled = false;
        event.preventDefault();
        return false;
      });
      this.contextMenu = sC;


      this.viewer.addEventListener('click',function(event){
        if(sC.enabled)
        {
        sC.style.opacity = 0;
        sC.enabled=false;
        self.viewer.controls.enabled = true;
        self.transformControls.enabled = true;
        }
      });
      this.addEventListener('reqShapeCreation',function(event){
        var type= event.detail.type;
        if(type)
        {
          var instance = null;
          switch(type)
          {
            case "Cube":
              instance = new Cube();
            break;
            case "Sphere":
              instance = new Sphere();
            break;
            case "Cylinder":
              instance = new Cylinder();
            break;
            case "Torus":
              instance = new Torus();
            break;
            case "Part":
              //var instance = new THREE.Mesh();
            break;
            case "Connector":
              instance = new Connector();
            break;
    
          }
          
          if(instance!=null){
            instance.name = type;
            instance.castShadows=true;
            instance.recieveShadows = true;

            geometry = instance.geometry;
            geometry.verticesNeedUpdate = true;
            geometry.normalsNeedUpdate = true;
            geometry.uvsNeedUpdate = true;
            geometry.computeCentroids();
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();
            geometry.computeMorphNormals();
            geometry.computeTangents();


            if(this.selectedObjects.length==1) //if we have a selection, add it to that selection
            {
             this.selectedObjects[0].add( instance ) ;
             instance.position.x +=30;
            }
            else
            {
              this.viewer.addToScene(instance);
              this.selectedObjects=[instance];
            }
            this.commandManager.addCommand( new Creation(instance, instance.parent) );
            console.log("instance", instance, this.viewer.scene);
          }
        }
     });
     
     this.addEventListener('reqShapeOperation',function(event){
        var type= event.detail.type;
        var selections = this.selectedObjects;

        function union(selections)
        {
          if(selections.length == 0) return;
          var operands = selections.slice(1);
          var result = selections[0].union( operands ); 
        }

        function subtract(selections)
        {
          if(selections.length == 0) return;
          var operands = selections.slice(1);
          var result = selections[0].subtract( operands ); 
          
          for(var i=0; i<operands.length;i++)
          {
            var operand = operands[i];
            operand.material.transparent=true; 
            operand.material.opacity =0.2;       
          }

        //TODO:develop this further: visual effect to make csg effects more clear
        setTimeout(function(){
        for(var i=0;i<operands.length;i++)
        {
          operands[i].material.opacity = 1;
          operands[i].material.transparent=false; 
        }

        },10000);
          
        }
        function intersect(selections)
        {
          if(selections.length == 0) return;
          var operands = selections.slice(1);
          var result = selections[0].intersect( operands ); 
        }


        if(type)
        {
          var result = null;
          switch(type)
          {
            case 'union':
              var target = selections[0];
              var oldGeometry = target.geometry.clone();

              result = union( selections );

              this.commandManager.addCommand( new Union(target, oldGeometry, selections.slice(1)) );
            break;
            case 'subtract':
              var target = selections[0];
              var oldGeometry = target.geometry.clone();

              result = subtract(selections);

              this.commandManager.addCommand( new Subtraction(target, oldGeometry, selections.slice(1) ) );
            break;
            case 'intersect':
              var target = selections[0];
              var oldGeometry = target.geometry.clone();

              result = intersect(selections);

              this.commandManager.addCommand( new Intersection(target, oldGeometry, selections.slice(1)) );
            break;

            //specials
            case 'mirrorX':
              var mesh = selections[0].parent.parent;
              var geometry = mesh.innerMesh.geometry;
              console.log("v",geometry);
              //geom.applyMatrix(new THREE.Matrix4().makeScale(1, -1, 1));
              //geom.computeFaceNormals();
              //geom.computeVertexNormals();

               var mS = (new THREE.Matrix4()).identity();
                mS.elements[0] = -1;//flip x

              var mat = new THREE.Matrix4().makeScale(-1, 1, 1);
              geometry.applyMatrix(mat);
              mesh.innerMesh.applyMatrix( mat );

              geometry.verticesNeedUpdate = true;
	            geometry.elementsNeedUpdate = true;
	            geometry.normalsNeedUpdate = true;
                //mesh.flipSided = true;

                for(var i = 0; i<geometry.faces.length; i++) {
                    geometry.faces[i].normal.x = -1*geometry.faces[i].normal.x;
                   geometry.faces[i].normal.y = -1*geometry.faces[i].normal.y;
                    geometry.faces[i].normal.z = -1*geometry.faces[i].normal.z;
                }
                geometry.computeVertexNormals();
                geometry.computeFaceNormals();
              mesh.innerMesh.material.side = THREE.DoubleSide;
              
            break;
            case 'clone':
              result = selections[0].clone();
            break;

            case 'linkedClone':
              selections[0].remove(selections[0].outline)
              var original = selections[0].parent.parent;
              result = original.clone();
              selections[0].add(selections[0].outline);

              //for visual helpers
              original.innerMesh.lClones = [result];
              result._original = original;

              result.name = original.name+"linkedClone";
              //console.log("result",result.shape,result.children[1]);
              //result.remove(result.shape);
              //result.remove(result.children[0]);
              original.addEventListener('shapeChanged',function(event){
                /*var source = event.target;
                console.log("in",result,"originalShapeChanged",this);
                var pos = result.innerMesh.position.clone();
                result.shape.remove( result.innerMesh);
                result.innerMesh = new THREE.Mesh(this.innerMesh.geometry.clone(), result.material);
                result.shape.add( result.innerMesh);
                result.innerMesh.position = pos;
                
                this.innerMesh.lClones = [result];
                result._original = this;

                var mS = (new THREE.Matrix4()).identity();
                mS.elements[0] = -1;*/
//flip x
                //mS.elements[5] = -1;
                //mS.elements[10] = -1;
                //result.innerMesh.geometry.applyMatrix(mS);
                //var mesh = result.innerMesh;

                //mesh.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));

                //mesh.geometry.applyMatrix(mS);
                //mesh.geometry.computeFaceNormals();
//mesh.geometry.computeVertexNormals();
    
                /*
                mesh.geometry.verticesNeedUpdate = true;
	              mesh.geometry.elementsNeedUpdate = true;
	              mesh.geometry.normalsNeedUpdate = true;
                //mesh.flipSided = true;

                for(var i = 0; i<mesh.geometry.faces.length; i++) {
                    mesh.geometry.faces[i].normal.x = -1*mesh.geometry.faces[i].normal.x;
                    mesh.geometry.faces[i].normal.y = -1*mesh.geometry.faces[i].normal.y;
                    mesh.geometry.faces[i].normal.z = -1*mesh.geometry.faces[i].normal.z;
                }*/
                //mesh.geometry.computeVertexNormals();
                //mesh.geometry.computeFaceNormals();
  
                //object.applyMatrix(mS);

              });
              //result.innerMesh = original.innerMesh;
              //result.shape = original.shape;
            break;
            
          }

          if(type != "clone" && type != "linkedClone" && type!='mirrorX')
          {
            /*var old = selections[0];
            delete old.__webglInit;
            old.geometry.dispose();
            old.geometry = result.geometry;*/

            
    
            //FIXME: hack hack hack !
            /*var old = selections[0];
            this.viewer.removeFromScene( old );
            var material = old.material.clone();  
            old.remove(old.children[0]);
            old.geometry.dispose();
            old.geometry = result.geometry;
            console.log(" old", old);
            old.material = material;
            this.viewer.renderer.initWebGLObjects(this.viewer.scene);

            this.viewer.addToScene( old );*/

            /*var old = selections[0];
            this.viewer.removeFromScene( old );
            
            old.geometry = result.geometry.clone();
            this.viewer.renderer.initWebGLObjects(this.viewer.scene);
            console.log("mlkml",this.viewer.renderer,this.viewer.scene);
            this.viewer.addToScene( old );*/


            /*var old = selections[0];
            this.viewer.removeFromScene( old );
            result.uuid = old.uuid;
            //res.children = old.children;
            result.name = old.name;
            result.material = old.material;
            old = null;
            selections[0] = result;
            this.viewer.addToScene( result );*/

            //var old = selections[0];
            //old.geometry.copy( result.geometry) ;//remove( old.innerMesh );
            //var nGeom = result.geometry.clone();
            
            /* implementation with linked cloning attmpt
            var old = selections[0];
            old = old.parent.parent;
            var savedOldGeometry = old.innerMesh.geometry.clone();
            console.log("old.shape",old.shape);
            var pos = old.innerMesh.position.clone();
            old.shape.remove( old.innerMesh);
            old.innerMesh = new THREE.Mesh(result.geometry, old.material);
            old.shape.add( old.innerMesh);
            old.innerMesh.position=pos;
            console.log("old.shape", old.shape);
            old.dispatchEvent( { type: 'shapeChanged' } );
            
            this.selectedObjects = [old.innerMesh];//make sure the new item is the selected one*/
            //old.geometry.setWrap(result.geometry.clone());
            //this.viewer.renderer.initWebGLObjects(this.viewer.scene);

            return;
          }
          if(type == 'mirrorX')
          {
          }
          else{
          this.viewer.addToScene( result );
          this.commandManager.addCommand( new Creation(result, result.parent) );
          this.selectedObjects = [result.innerMesh];//make sure the new item is the selected one
          
          }
        }
    });

    },
    selectedObjectsChanged:function(oldSelections, newSelections)
    {
      var newSelections = this.selectedObjects;
      //console.log("selection", newSelections,"old",oldSelections);
      
      if(!(oldSelections)) oldSelections = [];
      if(!(newSelections)) newSelections = [];
      if(oldSelections.length == 0 && newSelections.length == 0) { return }

      this.selectedObject = this.selectedObjects[0];

      this.transformControls.detach();
      this.viewer.removeFromScene(this.transformControls);
      
      //remove from old
      for(var i=oldSelections.length-1;i>=0;i--)
      {
        var oldSelection = oldSelections[i];
        if(!(oldSelection)) continue;
        //this.selectedObject.remove( oldSelection );
        //oldSelection.position.add( this.selectedObject.position );
        //this.viewer.addToScene( oldSelection );
        //oldSelection.controls = null;
        if(oldSelection.outline!=null)
        { 
          var outline = oldSelection.outline;
          oldSelection.remove(outline);
          delete oldSelection.outline;
        }
      }
      //add to new selection
      /*
      this.viewer.removeFromScene(this.selectedObject);
      this.selectedObject = null;
      if(newSelections.length>0)
      {
      this.selectedObject = new THREE.Object3D();//"group" object
      this.transformControls.attach( this.selectedObject ); 
      this.viewer.scene.add(this.transformControls);     
      this.viewer.addToScene(this.selectedObject);

        var avgPosition = new THREE.Vector3();

        for(var i= newSelections.length-1 ;i>=0;i--)
        {
          var newSelection = newSelections[i];
          avgPosition.add( newSelection.position );
        }
        avgPosition.divideScalar( newSelections.length );
        this.selectedObject.position = avgPosition;
      }*/
   
      if(newSelections.length>0)
      {
        this.contextMenu.mode = 'operations';
      }
      else
      {
        this.contextMenu.mode = 'creation';
      }
      for(var i= newSelections.length-1 ;i>=0;i--)
      {
        var newSelection = newSelections[i];
        if(!(newSelection)) continue;
        //helpers drawn on screen : TODO: cleanup
        //drawParentChildLinks(newSelection);
        //drawLinkToLinkedClones(newSelection);

        //if(this.selectedObject)this.selectedObject.add( newSelection );

        this.viewer.scene.add(this.transformControls);
        this.transformControls.attach( newSelections[0] ); 
        //console.log("this.viewer",this.viewer);
        //newSelection.controls = this.transformControls;

        if(newSelection.outline) continue;
        var outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,//0xffc200,
          side: THREE.BackSide
        });
        var outline = new THREE.Mesh(newSelection.geometry.clone(), outlineMaterial);
        outline.name = "selectOutline";
        outline.scale.multiplyScalar(1.03);
        newSelection.outline = outline;
        newSelection.add(outline);
      }
    },
    onMouseWheel:function (event)
    {
      //this blocks page scrolling if mouse is within this element
      event.preventDefault();
      return false;
    },
    keyUp:function(event)
    {
      var keyCode = event.impl.keyCode;
      var ctrlPressed = event.impl.ctrlKey;
      var shiftPressed= event.impl.shiftKey;

      switch(keyCode)
      {
        case 68://d
          console.log("pouet");
          if(ctrlPressed){
            this.fire("reqShapeOperation",{type:"clone"});
            console.log("duplicating");
            event.preventDefault();
          }
        break;
        case 71://g
          if(this.transformControls.space == "world") this.transformControls.setSpace("local");
          if(this.transformControls.space == "local") this.transformControls.setSpace("world");
        break;
        case 82://r
          console.log("set to rotate");
          this.transformControls.setMode("rotate");
        break;
        case 83:
          if(ctrlPressed)
          {
            console.log("wanna save?");
            event.preventDefault();
          return false;
          }
          console.log("set to scale");
          this.transformControls.setMode("scale");
          break;
        case 84:
          console.log("set to translate");
          this.transformControls.setMode("translate");
        case 90:
          if(ctrlPressed && shiftPressed) {
            this.commandManager.redo();return;
          } 
          if(ctrlPressed)
          {
            console.log("undo");
            // ctrl+z was typed.
            this.commandManager.undo();return;
          }
          break; 
        case 46:
          while((selectedObject=this.selectedObjects.pop()) != null){
            var parent = selectedObject.parent
            parent.remove(selectedObject);
            //TODO: need a more generic system to publish operation into the history
            this.commandManager.addCommand( new Deletion(selectedObject, parent) );
          }
        break;
      }

    },
    handleDragOver:function(e) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    console.log("drag over")
  },
    //going down "one level" into an object hierarchy
    });
  </script>
</polymer-element>
