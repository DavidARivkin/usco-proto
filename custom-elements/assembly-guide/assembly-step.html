
<!--temporary-->
<script src="../usco-shapes/lib/usco-shapes.js"></script>


<polymer-element name="assembly-step">
    <template>
      <style>
        :host{
          display:block;
          position:absolute;
          right:10px;
          z-index:10;
        }
        header{
          font-weight:bold;
        }
        
        core-icon{
  width:18px !important;
  height:18px !important;
  font-size:18px !important;
}

core-icon-button {
  display: inline-block;
  background-image: none;
  padding: 3px;
  margin: 2px;
width: inherit;
height: inherit;
  vertical-align: middle;
  cursor: pointer;
  
  border-top-left-radius: 0px;
border-top-right-radius: 0px;
border-bottom-right-radius: 0px;
border-bottom-left-radius: 0px;
}

core-icon-button.usco-light:hover{
            color:rgb(0, 153, 221);
}

core-item {
  display: block;
  height: 30px;
  cursor: pointer;
}

core-item .item-container > core-icon {
  margin: 0px 3px 0px 4px;
}

core-item.usco-light:hover{
            color:rgb(0, 153, 221);
}

core-theme-aware.usco-dark core-icon-button{
            color:red;
}

core-theme-aware.usco-light core-icon-button{
            color:black;
}

core-theme-aware.usco-light core-icon-button core-icon:hover{
            color:rgb(0, 153, 221);
}

core-theme-aware.usco-light core-icon-button.selected {
  background-color: rgba(71, 167, 255, 1);
  box-shadow: rgba(0, 0, 0, 0.0470588) 0px 1px 0px 0px inset, rgba(0, 0, 0, 0.117647) 0px 0px 0px 1px;
}
        
      </style>
      <header><div>Step:{{number}}/{{total}}</div><div>{{builds}}</div></header>
      <div>
        <b>Instructions:</b> {{text}}
      </div>
      <div>
        Parts:
        <table>
          <template repeat="{{part,partIndex in bom}}">
            <tr>
              <td>&nbsp  {{partIndex}}:</td><td> {{part.description}} :</td><td> {{part.amount}}x</td>
            </tr>
          </template>
        </table>
        Tools:
        <ul>
          <template repeat="{{tool,toolIndex in tools}}">
            <li>
              {{toolIndex}}: {{tool.name}}
            </li>
          </template>
        </ul>
      </div>
      <footer>
        <core-tooltip label="Play/Pause" position="bottom">
          <core-icon-button icon="fa-vid:{{ {'play':!isPlaying, 'pause':isPlaying} | tokenList }}" 
            on-tap="{{toggleAnimation}}">
         </core-icon-button>
        </core-tooltip>
        <core-tooltip label="Forward/Backwards" position="bottom">
          <core-icon-button icon="fa-vid:{{ {'backward':!isForward, 'forward':isForward} | tokenList }}" 
            on-tap="{{toggleAnimationDir}}">
          </core-icon-button>
        </core-tooltip>
        <core-tooltip label="repeat" position="bottom">
          <input type="checkbox" checked="{{isRepeating}}"> </input>
        </core-tooltip>
        <core-tooltip label="next step" position="bottom">
          <core-icon-button icon="fa-dirs:chevron-right" on-tap="{{reqNew}}"></core-icon-button>
        </core-tooltip>
        
        
      </footer>
    </template>
    <script>Polymer("assembly-step", {
      number:1,
      total:9,
      text:"do some stuff",
      builds:"AssembledCubion#4",
      bom:[
        {
           partNumber:1,
           description:"M3 Bolt",
           url:"",
           mimetype:"",
           thumbnailUrl:"",
           amount:3
        },
        {
           partNumber:2,
           description:"Printed Cube",
           url:"",
           mimetype:"",
           thumbnailUrl:"",
           amount:1
        },
      ],
      tools:[
        {name:"screwdriver"},
      ],
      actions:[
        "screw part #1 into part #2",
      ],
      autoPlay:true,
      isPlaying:false,
      isForward:true,
      isRepeating:false,
      isPlayingChanged:function(oldIsPlaying,isPlaying)
      { 
        if(oldIsPlaying)
        {
          for(var i=0;i<this._animations.length;i++)
          {
            var anim = this._animations[i];
            anim.stop();
          }        
        }
        else
        {
          for(var i=0;i<this._animations.length;i++)
          {
            var anim = this._animations[i];
            anim.start();
          } 
        }
      },
      isRepeatingChanged:function()
      {
        if(this.isRepeating)
        {
          for(var i=0;i<this._animations.length;i++)
          {
            var anim = this._animations[i];
            anim.repeat(Infinity);
          } 
        }
        else
        {
          for(var i=0;i<this._animations.length;i++)
          {
            var anim = this._animations[i];
            anim.repeat(0);
          } 
        }
      },
      toggleAnimation:function()
      {
        this.isPlaying =! this.isPlaying;
      },
      toggleAnimationDir:function()
      {
        for(var i=0;i<this._animations.length;i++)
        {
          var anim = this._animations[i];
          anim.stop().yoyo(true).start();
          //anim.easing( TWEEN.Easing.Back.InOut)
        }  
        this.isForward =! this.isForward;
      },
      created:function()
      {
        this._animations = [];
      },
      enteredView:function()
      {
        var self = this;
        window.addEventListener('polymer-ready', function() {
          self.initialize();    
          if(self.autoPlay)
          {
            self.isPlaying = true;
          }
        });
      },
      reverse:function()//this turns ins into outs , froms into tos etc
      {
      
      },
      initialize:function()
      {
        
        var threeViewer = document.querySelector('assembly-viewer');
        
        function makeBolt()
        {
          var boltHeight = 10;
          var geometry = new THREE.CylinderGeometry(3,3, boltHeight,6);
          geometry.applyMatrix(new THREE.Matrix4().makeRotationX( Math.PI / 2 ));
          
          var geometryHead = new THREE.CylinderGeometry(5,5, 2,10);
          geometryHead.applyMatrix(new THREE.Matrix4().makeRotationX( Math.PI / 2 ));
          geometryHead.applyMatrix(new THREE.Matrix4().makeTranslation( 0,0, -boltHeight/2 ));
          
          geometry.merge( geometryHead );
          
        	geometry.computeBoundingSphere();
          geometry.computeBoundingBox();
          var material = new THREE.MeshLambertMaterial( {opacity:1,transparent:true,color: 0xff8800} );
          var bolt = new THREE.Mesh(geometry, material);
          
          //connectors 
          //for bolt  
          //TODO: this is both a visual and a logic connector, should be seperate  
          var connectorSize = 2;
          var geometry = new THREE.BoxGeometry( connectorSize, connectorSize, connectorSize/2 ); 
        	geometry.computeBoundingSphere();
          geometry.computeBoundingBox();
	        var material = new THREE.MeshLambertMaterial( {opacity:1,transparent:true,color: 0xff0000,wireframe:true} ); 
	        var tipConnector = new THREE.Mesh(geometry, material);
	        
	        //bolt.add( tipConnector );
	        tipConnector.position.z = boltHeight/2;
	        
	        tipConnector.material.depthTest=false;
          tipConnector.material.depthWrite=false;
          tipConnector.renderDepth = 1e-20;
          
          
          var geometry = new THREE.BoxGeometry( connectorSize, connectorSize, connectorSize/2 ); 
        	geometry.computeBoundingSphere();
          geometry.computeBoundingBox();
	        var material = new THREE.MeshLambertMaterial( {opacity:1,transparent:true,color: 0xff0000,wireframe:true} ); 
	        var endConnector = new THREE.Mesh(geometry, material);
	        
	        //bolt.add( endConnector );
	        endConnector.position.z = -boltHeight/2;
	        
	        endConnector.material.depthTest=false;
          endConnector.material.depthWrite=false;
          endConnector.renderDepth = 1e-20;
          
          return bolt;
        }  
        
        function makeTargetCube()
        {
          var connectorSize = 2;
          var cubeSize = 30;
          var geometry = new THREE.BoxGeometry( cubeSize, cubeSize, cubeSize ); 
        	geometry.computeBoundingSphere();
          geometry.computeBoundingBox();
          var material = new THREE.MeshLambertMaterial( {opacity:1,transparent:false,color: 0x0088ff} ); 
          var cube = new THREE.Mesh(geometry, material);
          cube.name = "TargetCube";
          
          
          /*var geometry = new THREE.BoxGeometry( connectorSize, connectorSize, connectorSize/2 ); 
        	geometry.computeBoundingSphere();
          geometry.computeBoundingBox();
	        var material = new THREE.MeshLambertMaterial( {opacity:1,transparent:true,color: 0xff0000,wireframe:true} ); 
	        var attachConnector = new THREE.Mesh(geometry, material);
	        
	        attachConnector.connectorFor = "Bolts"
	        attachConnector.position.z = -cubeSize/2;
	        attachConnector.material.depthTest=false;
          attachConnector.material.depthWrite=false;
          attachConnector.renderDepth = 1e-20;
          
          var attachConnectorTop = attachConnector.clone();
          attachConnectorTop.position.z  = cubeSize/2;
          
          
          var attachConnectorSide = attachConnector.clone();
          attachConnectorSide.position.z  = 0;
          attachConnectorSide.position.x  = cubeSize/2;*/
          
          
          //cube.add( attachConnector );
          /*cube.add( attachConnectorTop );
          cube.add( attachConnectorSide );*/
          
          topConnector = new Connector();
          bottomConnector = new Connector();
          sideConnector = new Connector();
          
          topConnector.position.z = cubeSize/2;
          bottomConnector.position.z = -cubeSize/2;
          bottomConnector.up = new THREE.Vector3(0,0,-1);
          sideConnector.position.x = -cubeSize/2;
          sideConnector.up = new THREE.Vector3(-1,0,0);
          
          cube.connectors = [topConnector,bottomConnector, sideConnector];
          /*cube.connectors.push( attachConnector );
          cube.connectors.push( attachConnectorTop );
          cube.connectors.push( attachConnectorSide );*/
          
          /*var c = new Connector();
          cR = c.generateRenderables();
          cube.add( cR );*/
          
          for(var i =0;i<cube.connectors.length;i++)
          {
            cR = cube.connectors[i].generateRenderables({color:0x000001});
            cube.add( cR );
          }
	        
	        return cube;
        }
        

        
        var target2 = cube = makeTargetCube();
        threeViewer.addToScene( target2 );
        
        //threeViewer.addToScene( (new Connector().generateRenderables()) );
        //        threeViewer.addToScene( generateRenderables() );
        //build instruction anims tests
        
        for(var i=0;i<target2.connectors.length;i++)
        {
          var subject = bolt = makeBolt();
          threeViewer.addToScene( subject );
        
          var tgtConnector = target2.connectors[i];
          //usefull
          var tgtWorldPos = tgtConnector.localToWorld(tgtConnector.position).clone();
          //place bolts in the right place
          var offset = 50;
          var subjectAutoOffset = tgtWorldPos.clone().normalize().multiplyScalar( offset ); //.sub( new THREE.Vector3() );
          
          addAnimationForBolt(tgtConnector, subject, subjectAutoOffset, this._animations);
        }
        
        function addAnimationForBolt(targetConnector, subject, startAnchor, animations)
        {
          
          //var startAnchor = new THREE.Vector3(0,0,50);//new THREE.Vector3(-100,30,30);
          var endAnchor   = targetConnector.localToWorld(targetConnector.position).clone(); //target2.connectors[1].localToWorld(target2.connectors[1].position).clone();//new THREE.Vector3(0,0,0);
          
          //for now use up vector as reference
          subject.up = new THREE.Vector3(0,0,1);
          subject.position.copy( startAnchor );
          
          var dirVect = endAnchor.clone().sub( startAnchor );
          var dirVectNorm = dirVect.clone().normalize();
          
          var angle = startAnchor.angleTo(endAnchor); //new THREE.Vector3(1,0,0).cross( direction );
          
          subject.lookAt( endAnchor ) ;
          //visual indications
          var arrow = new DistanceHelper({start: startAnchor, end:endAnchor});
          threeViewer.addToScene( arrow );
          
          var duration = 3000;
          var turns = 6;
          var distance = 100;        
          var axis = new THREE.Vector3(1,0,0);

          var curPos = subject.position;
          var curRot = subject.rotation;
          
          var pos = endAnchor.clone();//new THREE.Vector3(100,20,0);
          var offs = 100;
          
          var curRot = new THREE.Euler();
          var targetRot = subject.rotation.clone();
          
          var translation = new TWEEN.Tween( subject.position )
            .to( { x: pos.x, y: pos.y, z:pos.z }, duration )
            //.yoyo(true)
            //.easing( TWEEN.Easing.Cubic.Out)
            //.repeat(Infinity);

            var r = turns * Math.PI//*2 ;// + curRot.rotation.z;
            var rotation = new TWEEN.Tween( subject.rotation )
              .to( { z:r}, duration )
              //.yoyo(true)
              //.easing( TWEEN.Easing.Cubic.Out)
              //.repeat(Infinity);
              
            animations.push( rotation );
            animations.push( translation );
            //this._animations.push( rotation );
            //this._animations.push( translation );
          }
      }
    });
    </script>
  </polymer-element>
